{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n/**\n * A tile bounding volume specified as a sphere.\n * @alias TileBoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {Number} [radius=0.0] The radius of the bounding sphere.\n *\n * @private\n */\n\nfunction TileBoundingSphere(center, radius) {\n  if (radius === 0) {\n    radius = CesiumMath.EPSILON7;\n  }\n\n  this._boundingSphere = new BoundingSphere(center, radius);\n}\n\nObject.defineProperties(TileBoundingSphere.prototype, {\n  /**\n   * The center of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  center: {\n    get: function () {\n      return this._boundingSphere.center;\n    }\n  },\n\n  /**\n   * The radius of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  radius: {\n    get: function () {\n      return this._boundingSphere.radius;\n    }\n  },\n\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  },\n\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    }\n  }\n});\n/**\n * Computes the distance between this bounding sphere and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {Number} The distance between the camera and the bounding sphere in meters. Returns 0 if the camera is inside the bounding volume.\n *\n */\n\nTileBoundingSphere.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState); //>>includeEnd('debug');\n\n  var boundingSphere = this._boundingSphere;\n  return Math.max(0.0, Cartesian3.distance(boundingSphere.center, frameState.camera.positionWC) - boundingSphere.radius);\n};\n/**\n * Determines which side of a plane this sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\n\n\nTileBoundingSphere.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane); //>>includeEnd('debug');\n\n  return BoundingSphere.intersectPlane(this._boundingSphere, plane);\n};\n/**\n * Update the bounding sphere after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the bounding sphere.\n * @param {Number} radius The radius of the bounding sphere.\n */\n\n\nTileBoundingSphere.prototype.update = function (center, radius) {\n  Cartesian3.clone(center, this._boundingSphere.center);\n  this._boundingSphere.radius = radius;\n};\n/**\n * Creates a debug primitive that shows the outline of the sphere.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\n\n\nTileBoundingSphere.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color); //>>includeEnd('debug');\n\n  var geometry = new SphereOutlineGeometry({\n    radius: this.radius\n  });\n  var modelMatrix = Matrix4.fromTranslation(this.center, new Matrix4.clone(Matrix4.IDENTITY));\n  var instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color)\n    }\n  });\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true\n    }),\n    asynchronous: false\n  });\n};\n\nexport default TileBoundingSphere;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/TileBoundingSphere.js"],"names":["BoundingSphere","Cartesian3","Check","ColorGeometryInstanceAttribute","GeometryInstance","CesiumMath","Matrix4","SphereOutlineGeometry","PerInstanceColorAppearance","Primitive","TileBoundingSphere","center","radius","EPSILON7","_boundingSphere","Object","defineProperties","prototype","get","boundingVolume","boundingSphere","distanceToCamera","frameState","defined","Math","max","distance","camera","positionWC","intersectPlane","plane","update","clone","createDebugVolume","color","geometry","modelMatrix","fromTranslation","IDENTITY","instance","id","attributes","fromColor","geometryInstances","appearance","translucent","flat","asynchronous"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\n\n/**\n * A tile bounding volume specified as a sphere.\n * @alias TileBoundingSphere\n * @constructor\n *\n * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.\n * @param {Number} [radius=0.0] The radius of the bounding sphere.\n *\n * @private\n */\nfunction TileBoundingSphere(center, radius) {\n  if (radius === 0) {\n    radius = CesiumMath.EPSILON7;\n  }\n  this._boundingSphere = new BoundingSphere(center, radius);\n}\n\nObject.defineProperties(TileBoundingSphere.prototype, {\n  /**\n   * The center of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  center: {\n    get: function () {\n      return this._boundingSphere.center;\n    },\n  },\n\n  /**\n   * The radius of the bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  radius: {\n    get: function () {\n      return this._boundingSphere.radius;\n    },\n  },\n\n  /**\n   * The underlying bounding volume\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {Object}\n   * @readonly\n   */\n  boundingVolume: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n  /**\n   * The underlying bounding sphere\n   *\n   * @memberof TileBoundingSphere.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   */\n  boundingSphere: {\n    get: function () {\n      return this._boundingSphere;\n    },\n  },\n});\n\n/**\n * Computes the distance between this bounding sphere and the camera attached to frameState.\n *\n * @param {FrameState} frameState The frameState to which the camera is attached.\n * @returns {Number} The distance between the camera and the bounding sphere in meters. Returns 0 if the camera is inside the bounding volume.\n *\n */\nTileBoundingSphere.prototype.distanceToCamera = function (frameState) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"frameState\", frameState);\n  //>>includeEnd('debug');\n  var boundingSphere = this._boundingSphere;\n  return Math.max(\n    0.0,\n    Cartesian3.distance(boundingSphere.center, frameState.camera.positionWC) -\n      boundingSphere.radius\n  );\n};\n\n/**\n * Determines which side of a plane this sphere is located.\n *\n * @param {Plane} plane The plane to test against.\n * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane\n *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is\n *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere\n *                      intersects the plane.\n */\nTileBoundingSphere.prototype.intersectPlane = function (plane) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"plane\", plane);\n  //>>includeEnd('debug');\n  return BoundingSphere.intersectPlane(this._boundingSphere, plane);\n};\n\n/**\n * Update the bounding sphere after the tile is transformed.\n *\n * @param {Cartesian3} center The center of the bounding sphere.\n * @param {Number} radius The radius of the bounding sphere.\n */\nTileBoundingSphere.prototype.update = function (center, radius) {\n  Cartesian3.clone(center, this._boundingSphere.center);\n  this._boundingSphere.radius = radius;\n};\n\n/**\n * Creates a debug primitive that shows the outline of the sphere.\n *\n * @param {Color} color The desired color of the primitive's mesh\n * @return {Primitive}\n */\nTileBoundingSphere.prototype.createDebugVolume = function (color) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"color\", color);\n  //>>includeEnd('debug');\n  var geometry = new SphereOutlineGeometry({\n    radius: this.radius,\n  });\n  var modelMatrix = Matrix4.fromTranslation(\n    this.center,\n    new Matrix4.clone(Matrix4.IDENTITY)\n  );\n  var instance = new GeometryInstance({\n    geometry: geometry,\n    id: \"outline\",\n    modelMatrix: modelMatrix,\n    attributes: {\n      color: ColorGeometryInstanceAttribute.fromColor(color),\n    },\n  });\n\n  return new Primitive({\n    geometryInstances: instance,\n    appearance: new PerInstanceColorAppearance({\n      translucent: false,\n      flat: true,\n    }),\n    asynchronous: false,\n  });\n};\nexport default TileBoundingSphere;\n"]},"metadata":{},"sourceType":"module"}