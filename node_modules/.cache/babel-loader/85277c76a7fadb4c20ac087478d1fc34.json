{"ast":null,"code":"import Check from \"./Check.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nvar compressedMagic = 0x7468dead;\nvar compressedMagicSwap = 0xadde6874;\n/**\n * Decodes data that is received from the Google Earth Enterprise server.\n *\n * @param {ArrayBuffer} key The key used during decoding.\n * @param {ArrayBuffer} data The data to be decoded.\n *\n * @private\n */\n\nfunction decodeGoogleEarthEnterpriseData(key, data) {\n  if (decodeGoogleEarthEnterpriseData.passThroughDataForTesting) {\n    return data;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  Check.typeOf.object(\"key\", key);\n  Check.typeOf.object(\"data\", data); //>>includeEnd('debug');\n\n  var keyLength = key.byteLength;\n\n  if (keyLength === 0 || keyLength % 4 !== 0) {\n    throw new RuntimeError(\"The length of key must be greater than 0 and a multiple of 4.\");\n  }\n\n  var dataView = new DataView(data);\n  var magic = dataView.getUint32(0, true);\n\n  if (magic === compressedMagic || magic === compressedMagicSwap) {\n    // Occasionally packets don't come back encoded, so just return\n    return data;\n  }\n\n  var keyView = new DataView(key);\n  var dp = 0;\n  var dpend = data.byteLength;\n  var dpend64 = dpend - dpend % 8;\n  var kpend = keyLength;\n  var kp;\n  var off = 8; // This algorithm is intentionally asymmetric to make it more difficult to\n  // guess. Security through obscurity. :-(\n  // while we have a full uint64 (8 bytes) left to do\n  // assumes buffer is 64bit aligned (or processor doesn't care)\n\n  while (dp < dpend64) {\n    // rotate the key each time through by using the offets 16,0,8,16,0,8,...\n    off = (off + 8) % 24;\n    kp = off; // run through one key length xor'ing one uint64 at a time\n    // then drop out to rotate the key for the next bit\n\n    while (dp < dpend64 && kp < kpend) {\n      dataView.setUint32(dp, dataView.getUint32(dp, true) ^ keyView.getUint32(kp, true), true);\n      dataView.setUint32(dp + 4, dataView.getUint32(dp + 4, true) ^ keyView.getUint32(kp + 4, true), true);\n      dp += 8;\n      kp += 24;\n    }\n  } // now the remaining 1 to 7 bytes\n\n\n  if (dp < dpend) {\n    if (kp >= kpend) {\n      // rotate the key one last time (if necessary)\n      off = (off + 8) % 24;\n      kp = off;\n    }\n\n    while (dp < dpend) {\n      dataView.setUint8(dp, dataView.getUint8(dp) ^ keyView.getUint8(kp));\n      dp++;\n      kp++;\n    }\n  }\n}\n\ndecodeGoogleEarthEnterpriseData.passThroughDataForTesting = false;\nexport default decodeGoogleEarthEnterpriseData;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/decodeGoogleEarthEnterpriseData.js"],"names":["Check","RuntimeError","compressedMagic","compressedMagicSwap","decodeGoogleEarthEnterpriseData","key","data","passThroughDataForTesting","typeOf","object","keyLength","byteLength","dataView","DataView","magic","getUint32","keyView","dp","dpend","dpend64","kpend","kp","off","setUint32","setUint8","getUint8"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport RuntimeError from \"./RuntimeError.js\";\n\nvar compressedMagic = 0x7468dead;\nvar compressedMagicSwap = 0xadde6874;\n\n/**\n * Decodes data that is received from the Google Earth Enterprise server.\n *\n * @param {ArrayBuffer} key The key used during decoding.\n * @param {ArrayBuffer} data The data to be decoded.\n *\n * @private\n */\nfunction decodeGoogleEarthEnterpriseData(key, data) {\n  if (decodeGoogleEarthEnterpriseData.passThroughDataForTesting) {\n    return data;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"key\", key);\n  Check.typeOf.object(\"data\", data);\n  //>>includeEnd('debug');\n\n  var keyLength = key.byteLength;\n  if (keyLength === 0 || keyLength % 4 !== 0) {\n    throw new RuntimeError(\n      \"The length of key must be greater than 0 and a multiple of 4.\"\n    );\n  }\n\n  var dataView = new DataView(data);\n  var magic = dataView.getUint32(0, true);\n  if (magic === compressedMagic || magic === compressedMagicSwap) {\n    // Occasionally packets don't come back encoded, so just return\n    return data;\n  }\n\n  var keyView = new DataView(key);\n\n  var dp = 0;\n  var dpend = data.byteLength;\n  var dpend64 = dpend - (dpend % 8);\n  var kpend = keyLength;\n  var kp;\n  var off = 8;\n\n  // This algorithm is intentionally asymmetric to make it more difficult to\n  // guess. Security through obscurity. :-(\n\n  // while we have a full uint64 (8 bytes) left to do\n  // assumes buffer is 64bit aligned (or processor doesn't care)\n  while (dp < dpend64) {\n    // rotate the key each time through by using the offets 16,0,8,16,0,8,...\n    off = (off + 8) % 24;\n    kp = off;\n\n    // run through one key length xor'ing one uint64 at a time\n    // then drop out to rotate the key for the next bit\n    while (dp < dpend64 && kp < kpend) {\n      dataView.setUint32(\n        dp,\n        dataView.getUint32(dp, true) ^ keyView.getUint32(kp, true),\n        true\n      );\n      dataView.setUint32(\n        dp + 4,\n        dataView.getUint32(dp + 4, true) ^ keyView.getUint32(kp + 4, true),\n        true\n      );\n      dp += 8;\n      kp += 24;\n    }\n  }\n\n  // now the remaining 1 to 7 bytes\n  if (dp < dpend) {\n    if (kp >= kpend) {\n      // rotate the key one last time (if necessary)\n      off = (off + 8) % 24;\n      kp = off;\n    }\n\n    while (dp < dpend) {\n      dataView.setUint8(dp, dataView.getUint8(dp) ^ keyView.getUint8(kp));\n      dp++;\n      kp++;\n    }\n  }\n}\n\ndecodeGoogleEarthEnterpriseData.passThroughDataForTesting = false;\nexport default decodeGoogleEarthEnterpriseData;\n"]},"metadata":{},"sourceType":"module"}