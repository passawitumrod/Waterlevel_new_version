{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport GoogleEarthEnterpriseMetadata from \"./GoogleEarthEnterpriseMetadata.js\";\nimport GoogleEarthEnterpriseTerrainData from \"./GoogleEarthEnterpriseTerrainData.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nvar TerrainState = {\n  UNKNOWN: 0,\n  NONE: 1,\n  SELF: 2,\n  PARENT: 3\n};\nvar julianDateScratch = new JulianDate();\n\nfunction TerrainCache() {\n  this._terrainCache = {};\n  this._lastTidy = JulianDate.now();\n}\n\nTerrainCache.prototype.add = function (quadKey, buffer) {\n  this._terrainCache[quadKey] = {\n    buffer: buffer,\n    timestamp: JulianDate.now()\n  };\n};\n\nTerrainCache.prototype.get = function (quadKey) {\n  var terrainCache = this._terrainCache;\n  var result = terrainCache[quadKey];\n\n  if (defined(result)) {\n    delete this._terrainCache[quadKey];\n    return result.buffer;\n  }\n};\n\nTerrainCache.prototype.tidy = function () {\n  JulianDate.now(julianDateScratch);\n\n  if (JulianDate.secondsDifference(julianDateScratch, this._lastTidy) > 10) {\n    var terrainCache = this._terrainCache;\n    var keys = Object.keys(terrainCache);\n    var count = keys.length;\n\n    for (var i = 0; i < count; ++i) {\n      var k = keys[i];\n      var e = terrainCache[k];\n\n      if (JulianDate.secondsDifference(julianDateScratch, e.timestamp) > 10) {\n        delete terrainCache[k];\n      }\n    }\n\n    JulianDate.clone(julianDateScratch, this._lastTidy);\n  }\n};\n/**\n * Provides tiled terrain using the Google Earth Enterprise REST API.\n *\n * @alias GoogleEarthEnterpriseTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url of the Google Earth Enterprise server hosting the imagery.\n * @param {GoogleEarthEnterpriseMetadata} options.metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @see GoogleEarthEnterpriseImageryProvider\n * @see CesiumTerrainProvider\n *\n * @example\n * var geeMetadata = new GoogleEarthEnterpriseMetadata('http://www.earthenterprise.org/3d');\n * var gee = new Cesium.GoogleEarthEnterpriseTerrainProvider({\n *     metadata : geeMetadata\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\n\n\nfunction GoogleEarthEnterpriseTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!(defined(options.url) || defined(options.metadata))) {\n    throw new DeveloperError(\"options.url or options.metadata is required.\");\n  } //>>includeEnd('debug');\n\n\n  var metadata;\n\n  if (defined(options.metadata)) {\n    metadata = options.metadata;\n  } else {\n    var resource = Resource.createIfNeeded(options.url);\n    metadata = new GoogleEarthEnterpriseMetadata(resource);\n  }\n\n  this._metadata = metadata;\n  this._tilingScheme = new GeographicTilingScheme({\n    numberOfLevelZeroTilesX: 2,\n    numberOfLevelZeroTilesY: 2,\n    rectangle: new Rectangle(-CesiumMath.PI, -CesiumMath.PI, CesiumMath.PI, CesiumMath.PI),\n    ellipsoid: options.ellipsoid\n  });\n  var credit = options.credit;\n\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  this._credit = credit; // Pulled from Google's documentation\n\n  this._levelZeroMaximumGeometricError = 40075.16;\n  this._terrainCache = new TerrainCache();\n  this._terrainPromises = {};\n  this._terrainRequests = {};\n  this._errorEvent = new Event();\n  this._ready = false;\n  var that = this;\n  var metadataError;\n  this._readyPromise = metadata.readyPromise.then(function (result) {\n    if (!metadata.terrainPresent) {\n      var e = new RuntimeError(\"The server \" + metadata.url + \" doesn't have terrain\");\n      metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, e.message, undefined, undefined, undefined, e);\n      return when.reject(e);\n    }\n\n    TileProviderError.handleSuccess(metadataError);\n    that._ready = result;\n    return result;\n  }).otherwise(function (e) {\n    metadataError = TileProviderError.handleError(metadataError, that, that._errorEvent, e.message, undefined, undefined, undefined, e);\n    return when.reject(e);\n  });\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainProvider.prototype, {\n  /**\n   * Gets the name of the Google Earth Enterprise server url hosting the imagery.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._metadata.url;\n    }\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._metadata.proxy;\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\"tilingScheme must not be called before the imagery provider is ready.\");\n      } //>>includeEnd('debug');\n\n\n      return this._tilingScheme;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    }\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    }\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TileAvailability}\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    }\n  }\n});\nvar taskProcessor = new TaskProcessor(\"decodeGoogleEarthEnterprisePacket\", Number.POSITIVE_INFINITY); // If the tile has its own terrain, then you can just use its child bitmask. If it was requested using it's parent\n//  then you need to check all of its children to see if they have terrain.\n\nfunction computeChildMask(quadKey, info, metadata) {\n  var childMask = info.getChildBitmask();\n\n  if (info.terrainState === TerrainState.PARENT) {\n    childMask = 0;\n\n    for (var i = 0; i < 4; ++i) {\n      var child = metadata.getTileInformationFromQuadKey(quadKey + i.toString());\n\n      if (defined(child) && child.hasTerrain()) {\n        childMask |= 1 << i;\n      }\n    }\n  }\n\n  return childMask;\n}\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n * @exception {DeveloperError} This function must not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready}\n *            returns true.\n */\n\n\nGoogleEarthEnterpriseTerrainProvider.prototype.requestTileGeometry = function (x, y, level, request) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!this._ready) {\n    throw new DeveloperError(\"requestTileGeometry must not be called before the terrain provider is ready.\");\n  } //>>includeEnd('debug');\n\n\n  var quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  var terrainCache = this._terrainCache;\n  var metadata = this._metadata;\n  var info = metadata.getTileInformationFromQuadKey(quadKey); // Check if this tile is even possibly available\n\n  if (!defined(info)) {\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  var terrainState = info.terrainState;\n\n  if (!defined(terrainState)) {\n    // First time we have tried to load this tile, so set terrain state to UNKNOWN\n    terrainState = info.terrainState = TerrainState.UNKNOWN;\n  } // If its in the cache, return it\n\n\n  var buffer = terrainCache.get(quadKey);\n\n  if (defined(buffer)) {\n    var credit = metadata.providers[info.terrainProvider];\n    return when.resolve(new GoogleEarthEnterpriseTerrainData({\n      buffer: buffer,\n      childTileMask: computeChildMask(quadKey, info, metadata),\n      credits: defined(credit) ? [credit] : undefined,\n      negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n      negativeElevationThreshold: metadata.negativeAltitudeThreshold\n    }));\n  } // Clean up the cache\n\n\n  terrainCache.tidy(); // We have a tile, check to see if no ancestors have terrain or that we know for sure it doesn't\n\n  if (!info.ancestorHasTerrain) {\n    // We haven't reached a level with terrain, so return the ellipsoid\n    return when.resolve(new HeightmapTerrainData({\n      buffer: new Uint8Array(16 * 16),\n      width: 16,\n      height: 16\n    }));\n  } else if (terrainState === TerrainState.NONE) {\n    // Already have info and there isn't any terrain here\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  } // Figure out where we are getting the terrain and what version\n\n\n  var parentInfo;\n  var q = quadKey;\n  var terrainVersion = -1;\n\n  switch (terrainState) {\n    case TerrainState.SELF:\n      // We have terrain and have retrieved it before\n      terrainVersion = info.terrainVersion;\n      break;\n\n    case TerrainState.PARENT:\n      // We have terrain in our parent\n      q = q.substring(0, q.length - 1);\n      parentInfo = metadata.getTileInformationFromQuadKey(q);\n      terrainVersion = parentInfo.terrainVersion;\n      break;\n\n    case TerrainState.UNKNOWN:\n      // We haven't tried to retrieve terrain yet\n      if (info.hasTerrain()) {\n        terrainVersion = info.terrainVersion; // We should have terrain\n      } else {\n        q = q.substring(0, q.length - 1);\n        parentInfo = metadata.getTileInformationFromQuadKey(q);\n\n        if (defined(parentInfo) && parentInfo.hasTerrain()) {\n          terrainVersion = parentInfo.terrainVersion; // Try checking in the parent\n        }\n      }\n\n      break;\n  } // We can't figure out where to get the terrain\n\n\n  if (terrainVersion < 0) {\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  } // Load that terrain\n\n\n  var terrainPromises = this._terrainPromises;\n  var terrainRequests = this._terrainRequests;\n  var sharedPromise;\n  var sharedRequest;\n\n  if (defined(terrainPromises[q])) {\n    // Already being loaded possibly from another child, so return existing promise\n    sharedPromise = terrainPromises[q];\n    sharedRequest = terrainRequests[q];\n  } else {\n    // Create new request for terrain\n    sharedRequest = request;\n    var requestPromise = buildTerrainResource(this, q, terrainVersion, sharedRequest).fetchArrayBuffer();\n\n    if (!defined(requestPromise)) {\n      return undefined; // Throttled\n    }\n\n    sharedPromise = requestPromise.then(function (terrain) {\n      if (defined(terrain)) {\n        return taskProcessor.scheduleTask({\n          buffer: terrain,\n          type: \"Terrain\",\n          key: metadata.key\n        }, [terrain]).then(function (terrainTiles) {\n          // Add requested tile and mark it as SELF\n          var requestedInfo = metadata.getTileInformationFromQuadKey(q);\n          requestedInfo.terrainState = TerrainState.SELF;\n          terrainCache.add(q, terrainTiles[0]);\n          var provider = requestedInfo.terrainProvider; // Add children to cache\n\n          var count = terrainTiles.length - 1;\n\n          for (var j = 0; j < count; ++j) {\n            var childKey = q + j.toString();\n            var child = metadata.getTileInformationFromQuadKey(childKey);\n\n            if (defined(child)) {\n              terrainCache.add(childKey, terrainTiles[j + 1]);\n              child.terrainState = TerrainState.PARENT;\n\n              if (child.terrainProvider === 0) {\n                child.terrainProvider = provider;\n              }\n            }\n          }\n        });\n      }\n\n      return when.reject(new RuntimeError(\"Failed to load terrain.\"));\n    });\n    terrainPromises[q] = sharedPromise; // Store promise without delete from terrainPromises\n\n    terrainRequests[q] = sharedRequest; // Set promise so we remove from terrainPromises just one time\n\n    sharedPromise = sharedPromise.always(function () {\n      delete terrainPromises[q];\n      delete terrainRequests[q];\n    });\n  }\n\n  return sharedPromise.then(function () {\n    var buffer = terrainCache.get(quadKey);\n\n    if (defined(buffer)) {\n      var credit = metadata.providers[info.terrainProvider];\n      return new GoogleEarthEnterpriseTerrainData({\n        buffer: buffer,\n        childTileMask: computeChildMask(quadKey, info, metadata),\n        credits: defined(credit) ? [credit] : undefined,\n        negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n        negativeElevationThreshold: metadata.negativeAltitudeThreshold\n      });\n    }\n\n    return when.reject(new RuntimeError(\"Failed to load terrain.\"));\n  }).otherwise(function (error) {\n    if (sharedRequest.state === RequestState.CANCELLED) {\n      request.state = sharedRequest.state;\n      return when.reject(error);\n    }\n\n    info.terrainState = TerrainState.NONE;\n    return when.reject(error);\n  });\n};\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\n\n\nGoogleEarthEnterpriseTerrainProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported, otherwise true or false.\n */\n\n\nGoogleEarthEnterpriseTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {\n  var metadata = this._metadata;\n  var quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  var info = metadata.getTileInformation(x, y, level);\n\n  if (info === null) {\n    return false;\n  }\n\n  if (defined(info)) {\n    if (!info.ancestorHasTerrain) {\n      return true; // We'll just return the ellipsoid\n    }\n\n    var terrainState = info.terrainState;\n\n    if (terrainState === TerrainState.NONE) {\n      return false; // Terrain is not available\n    }\n\n    if (!defined(terrainState) || terrainState === TerrainState.UNKNOWN) {\n      info.terrainState = TerrainState.UNKNOWN;\n\n      if (!info.hasTerrain()) {\n        quadKey = quadKey.substring(0, quadKey.length - 1);\n        var parentInfo = metadata.getTileInformationFromQuadKey(quadKey);\n\n        if (!defined(parentInfo) || !parentInfo.hasTerrain()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  if (metadata.isValid(quadKey)) {\n    // We will need this tile, so request metadata and return false for now\n    var request = new Request({\n      throttle: true,\n      throttleByServer: true,\n      type: RequestType.TERRAIN\n    });\n    metadata.populateSubtree(x, y, level, request);\n  }\n\n  return false;\n};\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\n\n\nGoogleEarthEnterpriseTerrainProvider.prototype.loadTileDataAvailability = function (x, y, level) {\n  return undefined;\n}; //\n// Functions to handle imagery packets\n//\n\n\nfunction buildTerrainResource(terrainProvider, quadKey, version, request) {\n  version = defined(version) && version > 0 ? version : 1;\n  return terrainProvider._metadata.resource.getDerivedResource({\n    url: \"flatfile?f1c-0\" + quadKey + \"-t.\" + version.toString(),\n    request: request\n  });\n}\n\nexport default GoogleEarthEnterpriseTerrainProvider;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/GoogleEarthEnterpriseTerrainProvider.js"],"names":["when","Credit","defaultValue","defined","DeveloperError","Event","GeographicTilingScheme","GoogleEarthEnterpriseMetadata","GoogleEarthEnterpriseTerrainData","HeightmapTerrainData","JulianDate","CesiumMath","Rectangle","Request","RequestState","RequestType","Resource","RuntimeError","TaskProcessor","TileProviderError","TerrainState","UNKNOWN","NONE","SELF","PARENT","julianDateScratch","TerrainCache","_terrainCache","_lastTidy","now","prototype","add","quadKey","buffer","timestamp","get","terrainCache","result","tidy","secondsDifference","keys","Object","count","length","i","k","e","clone","GoogleEarthEnterpriseTerrainProvider","options","EMPTY_OBJECT","url","metadata","resource","createIfNeeded","_metadata","_tilingScheme","numberOfLevelZeroTilesX","numberOfLevelZeroTilesY","rectangle","PI","ellipsoid","credit","_credit","_levelZeroMaximumGeometricError","_terrainPromises","_terrainRequests","_errorEvent","_ready","that","metadataError","_readyPromise","readyPromise","then","terrainPresent","handleError","message","undefined","reject","handleSuccess","otherwise","defineProperties","proxy","tilingScheme","errorEvent","ready","hasWaterMask","hasVertexNormals","availability","taskProcessor","Number","POSITIVE_INFINITY","computeChildMask","info","childMask","getChildBitmask","terrainState","child","getTileInformationFromQuadKey","toString","hasTerrain","requestTileGeometry","x","y","level","request","tileXYToQuadKey","providers","terrainProvider","resolve","childTileMask","credits","negativeAltitudeExponentBias","negativeElevationThreshold","negativeAltitudeThreshold","ancestorHasTerrain","Uint8Array","width","height","parentInfo","q","terrainVersion","substring","terrainPromises","terrainRequests","sharedPromise","sharedRequest","requestPromise","buildTerrainResource","fetchArrayBuffer","terrain","scheduleTask","type","key","terrainTiles","requestedInfo","provider","j","childKey","always","error","state","CANCELLED","getLevelMaximumGeometricError","getTileDataAvailable","getTileInformation","isValid","throttle","throttleByServer","TERRAIN","populateSubtree","loadTileDataAvailability","version","getDerivedResource"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport GoogleEarthEnterpriseMetadata from \"./GoogleEarthEnterpriseMetadata.js\";\nimport GoogleEarthEnterpriseTerrainData from \"./GoogleEarthEnterpriseTerrainData.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport JulianDate from \"./JulianDate.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TileProviderError from \"./TileProviderError.js\";\n\nvar TerrainState = {\n  UNKNOWN: 0,\n  NONE: 1,\n  SELF: 2,\n  PARENT: 3,\n};\n\nvar julianDateScratch = new JulianDate();\n\nfunction TerrainCache() {\n  this._terrainCache = {};\n  this._lastTidy = JulianDate.now();\n}\n\nTerrainCache.prototype.add = function (quadKey, buffer) {\n  this._terrainCache[quadKey] = {\n    buffer: buffer,\n    timestamp: JulianDate.now(),\n  };\n};\n\nTerrainCache.prototype.get = function (quadKey) {\n  var terrainCache = this._terrainCache;\n  var result = terrainCache[quadKey];\n  if (defined(result)) {\n    delete this._terrainCache[quadKey];\n    return result.buffer;\n  }\n};\n\nTerrainCache.prototype.tidy = function () {\n  JulianDate.now(julianDateScratch);\n  if (JulianDate.secondsDifference(julianDateScratch, this._lastTidy) > 10) {\n    var terrainCache = this._terrainCache;\n    var keys = Object.keys(terrainCache);\n    var count = keys.length;\n    for (var i = 0; i < count; ++i) {\n      var k = keys[i];\n      var e = terrainCache[k];\n      if (JulianDate.secondsDifference(julianDateScratch, e.timestamp) > 10) {\n        delete terrainCache[k];\n      }\n    }\n\n    JulianDate.clone(julianDateScratch, this._lastTidy);\n  }\n};\n\n/**\n * Provides tiled terrain using the Google Earth Enterprise REST API.\n *\n * @alias GoogleEarthEnterpriseTerrainProvider\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url of the Google Earth Enterprise server hosting the imagery.\n * @param {GoogleEarthEnterpriseMetadata} options.metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.\n * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n *\n * @see GoogleEarthEnterpriseImageryProvider\n * @see CesiumTerrainProvider\n *\n * @example\n * var geeMetadata = new GoogleEarthEnterpriseMetadata('http://www.earthenterprise.org/3d');\n * var gee = new Cesium.GoogleEarthEnterpriseTerrainProvider({\n *     metadata : geeMetadata\n * });\n *\n * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}\n */\nfunction GoogleEarthEnterpriseTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!(defined(options.url) || defined(options.metadata))) {\n    throw new DeveloperError(\"options.url or options.metadata is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var metadata;\n  if (defined(options.metadata)) {\n    metadata = options.metadata;\n  } else {\n    var resource = Resource.createIfNeeded(options.url);\n    metadata = new GoogleEarthEnterpriseMetadata(resource);\n  }\n\n  this._metadata = metadata;\n  this._tilingScheme = new GeographicTilingScheme({\n    numberOfLevelZeroTilesX: 2,\n    numberOfLevelZeroTilesY: 2,\n    rectangle: new Rectangle(\n      -CesiumMath.PI,\n      -CesiumMath.PI,\n      CesiumMath.PI,\n      CesiumMath.PI\n    ),\n    ellipsoid: options.ellipsoid,\n  });\n\n  var credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Pulled from Google's documentation\n  this._levelZeroMaximumGeometricError = 40075.16;\n\n  this._terrainCache = new TerrainCache();\n  this._terrainPromises = {};\n  this._terrainRequests = {};\n\n  this._errorEvent = new Event();\n\n  this._ready = false;\n  var that = this;\n  var metadataError;\n  this._readyPromise = metadata.readyPromise\n    .then(function (result) {\n      if (!metadata.terrainPresent) {\n        var e = new RuntimeError(\n          \"The server \" + metadata.url + \" doesn't have terrain\"\n        );\n        metadataError = TileProviderError.handleError(\n          metadataError,\n          that,\n          that._errorEvent,\n          e.message,\n          undefined,\n          undefined,\n          undefined,\n          e\n        );\n        return when.reject(e);\n      }\n\n      TileProviderError.handleSuccess(metadataError);\n      that._ready = result;\n      return result;\n    })\n    .otherwise(function (e) {\n      metadataError = TileProviderError.handleError(\n        metadataError,\n        that,\n        that._errorEvent,\n        e.message,\n        undefined,\n        undefined,\n        undefined,\n        e\n      );\n      return when.reject(e);\n    });\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainProvider.prototype, {\n  /**\n   * Gets the name of the Google Earth Enterprise server url hosting the imagery.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {String}\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._metadata.url;\n    },\n  },\n\n  /**\n   * Gets the proxy used by this provider.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Proxy}\n   * @readonly\n   */\n  proxy: {\n    get: function () {\n      return this._metadata.proxy;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.  This function should\n   * not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (!this._ready) {\n        throw new DeveloperError(\n          \"tilingScheme must not be called before the imagery provider is ready.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves to true when the provider is ready for use.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Promise.<Boolean>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.  This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.  This function should not be\n   * called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {Boolean}\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles.  This function should not be called before\n   * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  This property may be undefined if availability\n   * information is not available.\n   * @memberof GoogleEarthEnterpriseTerrainProvider.prototype\n   * @type {TileAvailability}\n   */\n  availability: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\nvar taskProcessor = new TaskProcessor(\n  \"decodeGoogleEarthEnterprisePacket\",\n  Number.POSITIVE_INFINITY\n);\n\n// If the tile has its own terrain, then you can just use its child bitmask. If it was requested using it's parent\n//  then you need to check all of its children to see if they have terrain.\nfunction computeChildMask(quadKey, info, metadata) {\n  var childMask = info.getChildBitmask();\n  if (info.terrainState === TerrainState.PARENT) {\n    childMask = 0;\n    for (var i = 0; i < 4; ++i) {\n      var child = metadata.getTileInformationFromQuadKey(\n        quadKey + i.toString()\n      );\n      if (defined(child) && child.hasTerrain()) {\n        childMask |= 1 << i;\n      }\n    }\n  }\n\n  return childMask;\n}\n\n/**\n * Requests the geometry for a given tile.  This function should not be called before\n * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  The result must include terrain data and\n * may optionally include a water mask and an indication of which child tiles are available.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n *\n * @exception {DeveloperError} This function must not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready}\n *            returns true.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!this._ready) {\n    throw new DeveloperError(\n      \"requestTileGeometry must not be called before the terrain provider is ready.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n  var terrainCache = this._terrainCache;\n  var metadata = this._metadata;\n  var info = metadata.getTileInformationFromQuadKey(quadKey);\n\n  // Check if this tile is even possibly available\n  if (!defined(info)) {\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  var terrainState = info.terrainState;\n  if (!defined(terrainState)) {\n    // First time we have tried to load this tile, so set terrain state to UNKNOWN\n    terrainState = info.terrainState = TerrainState.UNKNOWN;\n  }\n\n  // If its in the cache, return it\n  var buffer = terrainCache.get(quadKey);\n  if (defined(buffer)) {\n    var credit = metadata.providers[info.terrainProvider];\n    return when.resolve(\n      new GoogleEarthEnterpriseTerrainData({\n        buffer: buffer,\n        childTileMask: computeChildMask(quadKey, info, metadata),\n        credits: defined(credit) ? [credit] : undefined,\n        negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n        negativeElevationThreshold: metadata.negativeAltitudeThreshold,\n      })\n    );\n  }\n\n  // Clean up the cache\n  terrainCache.tidy();\n\n  // We have a tile, check to see if no ancestors have terrain or that we know for sure it doesn't\n  if (!info.ancestorHasTerrain) {\n    // We haven't reached a level with terrain, so return the ellipsoid\n    return when.resolve(\n      new HeightmapTerrainData({\n        buffer: new Uint8Array(16 * 16),\n        width: 16,\n        height: 16,\n      })\n    );\n  } else if (terrainState === TerrainState.NONE) {\n    // Already have info and there isn't any terrain here\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Figure out where we are getting the terrain and what version\n  var parentInfo;\n  var q = quadKey;\n  var terrainVersion = -1;\n  switch (terrainState) {\n    case TerrainState.SELF: // We have terrain and have retrieved it before\n      terrainVersion = info.terrainVersion;\n      break;\n    case TerrainState.PARENT: // We have terrain in our parent\n      q = q.substring(0, q.length - 1);\n      parentInfo = metadata.getTileInformationFromQuadKey(q);\n      terrainVersion = parentInfo.terrainVersion;\n      break;\n    case TerrainState.UNKNOWN: // We haven't tried to retrieve terrain yet\n      if (info.hasTerrain()) {\n        terrainVersion = info.terrainVersion; // We should have terrain\n      } else {\n        q = q.substring(0, q.length - 1);\n        parentInfo = metadata.getTileInformationFromQuadKey(q);\n        if (defined(parentInfo) && parentInfo.hasTerrain()) {\n          terrainVersion = parentInfo.terrainVersion; // Try checking in the parent\n        }\n      }\n      break;\n  }\n\n  // We can't figure out where to get the terrain\n  if (terrainVersion < 0) {\n    return when.reject(new RuntimeError(\"Terrain tile doesn't exist\"));\n  }\n\n  // Load that terrain\n  var terrainPromises = this._terrainPromises;\n  var terrainRequests = this._terrainRequests;\n  var sharedPromise;\n  var sharedRequest;\n  if (defined(terrainPromises[q])) {\n    // Already being loaded possibly from another child, so return existing promise\n    sharedPromise = terrainPromises[q];\n    sharedRequest = terrainRequests[q];\n  } else {\n    // Create new request for terrain\n    sharedRequest = request;\n    var requestPromise = buildTerrainResource(\n      this,\n      q,\n      terrainVersion,\n      sharedRequest\n    ).fetchArrayBuffer();\n\n    if (!defined(requestPromise)) {\n      return undefined; // Throttled\n    }\n\n    sharedPromise = requestPromise.then(function (terrain) {\n      if (defined(terrain)) {\n        return taskProcessor\n          .scheduleTask(\n            {\n              buffer: terrain,\n              type: \"Terrain\",\n              key: metadata.key,\n            },\n            [terrain]\n          )\n          .then(function (terrainTiles) {\n            // Add requested tile and mark it as SELF\n            var requestedInfo = metadata.getTileInformationFromQuadKey(q);\n            requestedInfo.terrainState = TerrainState.SELF;\n            terrainCache.add(q, terrainTiles[0]);\n            var provider = requestedInfo.terrainProvider;\n\n            // Add children to cache\n            var count = terrainTiles.length - 1;\n            for (var j = 0; j < count; ++j) {\n              var childKey = q + j.toString();\n              var child = metadata.getTileInformationFromQuadKey(childKey);\n              if (defined(child)) {\n                terrainCache.add(childKey, terrainTiles[j + 1]);\n                child.terrainState = TerrainState.PARENT;\n                if (child.terrainProvider === 0) {\n                  child.terrainProvider = provider;\n                }\n              }\n            }\n          });\n      }\n\n      return when.reject(new RuntimeError(\"Failed to load terrain.\"));\n    });\n\n    terrainPromises[q] = sharedPromise; // Store promise without delete from terrainPromises\n    terrainRequests[q] = sharedRequest;\n\n    // Set promise so we remove from terrainPromises just one time\n    sharedPromise = sharedPromise.always(function () {\n      delete terrainPromises[q];\n      delete terrainRequests[q];\n    });\n  }\n\n  return sharedPromise\n    .then(function () {\n      var buffer = terrainCache.get(quadKey);\n      if (defined(buffer)) {\n        var credit = metadata.providers[info.terrainProvider];\n        return new GoogleEarthEnterpriseTerrainData({\n          buffer: buffer,\n          childTileMask: computeChildMask(quadKey, info, metadata),\n          credits: defined(credit) ? [credit] : undefined,\n          negativeAltitudeExponentBias: metadata.negativeAltitudeExponentBias,\n          negativeElevationThreshold: metadata.negativeAltitudeThreshold,\n        });\n      }\n\n      return when.reject(new RuntimeError(\"Failed to load terrain.\"));\n    })\n    .otherwise(function (error) {\n      if (sharedRequest.state === RequestState.CANCELLED) {\n        request.state = sharedRequest.state;\n        return when.reject(error);\n      }\n      info.terrainState = TerrainState.NONE;\n      return when.reject(error);\n    });\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {Boolean} Undefined if not supported, otherwise true or false.\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  var metadata = this._metadata;\n  var quadKey = GoogleEarthEnterpriseMetadata.tileXYToQuadKey(x, y, level);\n\n  var info = metadata.getTileInformation(x, y, level);\n  if (info === null) {\n    return false;\n  }\n\n  if (defined(info)) {\n    if (!info.ancestorHasTerrain) {\n      return true; // We'll just return the ellipsoid\n    }\n\n    var terrainState = info.terrainState;\n    if (terrainState === TerrainState.NONE) {\n      return false; // Terrain is not available\n    }\n\n    if (!defined(terrainState) || terrainState === TerrainState.UNKNOWN) {\n      info.terrainState = TerrainState.UNKNOWN;\n      if (!info.hasTerrain()) {\n        quadKey = quadKey.substring(0, quadKey.length - 1);\n        var parentInfo = metadata.getTileInformationFromQuadKey(quadKey);\n        if (!defined(parentInfo) || !parentInfo.hasTerrain()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  if (metadata.isValid(quadKey)) {\n    // We will need this tile, so request metadata and return false for now\n    var request = new Request({\n      throttle: true,\n      throttleByServer: true,\n      type: RequestType.TERRAIN,\n    });\n    metadata.populateSubtree(x, y, level, request);\n  }\n  return false;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {Number} x The X coordinate of the tile for which to request geometry.\n * @param {Number} y The Y coordinate of the tile for which to request geometry.\n * @param {Number} level The level of the tile for which to request geometry.\n * @returns {undefined|Promise} Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded\n */\nGoogleEarthEnterpriseTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\n//\n// Functions to handle imagery packets\n//\nfunction buildTerrainResource(terrainProvider, quadKey, version, request) {\n  version = defined(version) && version > 0 ? version : 1;\n  return terrainProvider._metadata.resource.getDerivedResource({\n    url: \"flatfile?f1c-0\" + quadKey + \"-t.\" + version.toString(),\n    request: request,\n  });\n}\nexport default GoogleEarthEnterpriseTerrainProvider;\n"]},"metadata":{},"sourceType":"module"}