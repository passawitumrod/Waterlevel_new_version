{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Visibility from \"./Visibility.js\";\n/**\n * Creates an Occluder derived from an object's position and radius, as well as the camera position.\n * The occluder can be used to determine whether or not other objects are visible or hidden behind the\n * visible horizon defined by the occluder and camera position.\n *\n * @alias Occluder\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n *\n * @constructor\n *\n * @example\n * // Construct an occluder one unit away from the origin with a radius of one.\n * var cameraPosition = Cesium.Cartesian3.ZERO;\n * var occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * var occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n */\n\nfunction Occluder(occluderBoundingSphere, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  this._occluderRadius = occluderBoundingSphere.radius;\n  this._horizonDistance = 0.0;\n  this._horizonPlaneNormal = undefined;\n  this._horizonPlanePosition = undefined;\n  this._cameraPosition = undefined; // cameraPosition fills in the above values\n\n  this.cameraPosition = cameraPosition;\n}\n\nvar scratchCartesian3 = new Cartesian3();\nObject.defineProperties(Occluder.prototype, {\n  /**\n   * The position of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._occluderPosition;\n    }\n  },\n\n  /**\n   * The radius of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Number}\n   */\n  radius: {\n    get: function () {\n      return this._occluderRadius;\n    }\n  },\n\n  /**\n   * The position of the camera.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    set: function (cameraPosition) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(cameraPosition)) {\n        throw new DeveloperError(\"cameraPosition is required.\");\n      } //>>includeEnd('debug');\n\n\n      cameraPosition = Cartesian3.clone(cameraPosition, this._cameraPosition);\n      var cameraToOccluderVec = Cartesian3.subtract(this._occluderPosition, cameraPosition, scratchCartesian3);\n      var invCameraToOccluderDistance = Cartesian3.magnitudeSquared(cameraToOccluderVec);\n      var occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;\n      var horizonDistance;\n      var horizonPlaneNormal;\n      var horizonPlanePosition;\n\n      if (invCameraToOccluderDistance > occluderRadiusSqrd) {\n        horizonDistance = Math.sqrt(invCameraToOccluderDistance - occluderRadiusSqrd);\n        invCameraToOccluderDistance = 1.0 / Math.sqrt(invCameraToOccluderDistance);\n        horizonPlaneNormal = Cartesian3.multiplyByScalar(cameraToOccluderVec, invCameraToOccluderDistance, scratchCartesian3);\n        var nearPlaneDistance = horizonDistance * horizonDistance * invCameraToOccluderDistance;\n        horizonPlanePosition = Cartesian3.add(cameraPosition, Cartesian3.multiplyByScalar(horizonPlaneNormal, nearPlaneDistance, scratchCartesian3), scratchCartesian3);\n      } else {\n        horizonDistance = Number.MAX_VALUE;\n      }\n\n      this._horizonDistance = horizonDistance;\n      this._horizonPlaneNormal = horizonPlaneNormal;\n      this._horizonPlanePosition = horizonPlanePosition;\n      this._cameraPosition = cameraPosition;\n    }\n  }\n});\n/**\n * Creates an occluder from a bounding sphere and the camera position.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n * @param {Occluder} [result] The object onto which to store the result.\n * @returns {Occluder} The occluder derived from an object's position and radius, as well as the camera position.\n */\n\nOccluder.fromBoundingSphere = function (occluderBoundingSphere, cameraPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    return new Occluder(occluderBoundingSphere, cameraPosition);\n  }\n\n  Cartesian3.clone(occluderBoundingSphere.center, result._occluderPosition);\n  result._occluderRadius = occluderBoundingSphere.radius;\n  result.cameraPosition = cameraPosition;\n  return result;\n};\n\nvar tempVecScratch = new Cartesian3();\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point surrounding the occludee object.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * var occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * var point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n * @see Occluder#computeVisibility\n */\n\nOccluder.prototype.isPointVisible = function (occludee) {\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    var tempVec = Cartesian3.subtract(occludee, this._occluderPosition, tempVecScratch);\n    var temp = this._occluderRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n\n    if (temp > 0.0) {\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);\n      return temp * temp > Cartesian3.magnitudeSquared(tempVec);\n    }\n  }\n\n  return false;\n};\n\nvar occludeePositionScratch = new Cartesian3();\n/**\n * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * var occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * var bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n * @see Occluder#computeVisibility\n */\n\nOccluder.prototype.isBoundingSphereVisible = function (occludee) {\n  var occludeePosition = Cartesian3.clone(occludee.center, occludeePositionScratch);\n  var occludeeRadius = occludee.radius;\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    var tempVec = Cartesian3.subtract(occludeePosition, this._occluderPosition, tempVecScratch);\n    var temp = this._occluderRadius - occludeeRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n\n    if (occludeeRadius < this._occluderRadius) {\n      if (temp > 0.0) {\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);\n        return temp * temp + occludeeRadius * occludeeRadius > Cartesian3.magnitudeSquared(tempVec);\n      }\n\n      return false;\n    } // Prevent against the case where the occludee radius is larger than the occluder's; since this is\n    // an uncommon case, the following code should rarely execute.\n\n\n    if (temp > 0.0) {\n      tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);\n      var tempVecMagnitudeSquared = Cartesian3.magnitudeSquared(tempVec);\n      var occluderRadiusSquared = this._occluderRadius * this._occluderRadius;\n      var occludeeRadiusSquared = occludeeRadius * occludeeRadius;\n\n      if ((this._horizonDistance * this._horizonDistance + occluderRadiusSquared) * occludeeRadiusSquared > tempVecMagnitudeSquared * occluderRadiusSquared) {\n        // The occludee is close enough that the occluder cannot possible occlude the occludee\n        return true;\n      }\n\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      return temp * temp + occludeeRadiusSquared > tempVecMagnitudeSquared;\n    } // The occludee completely encompasses the occluder\n\n\n    return true;\n  }\n\n  return false;\n};\n\nvar tempScratch = new Cartesian3();\n/**\n * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).\n *\n * @param {BoundingSphere} occludeeBS The bounding sphere of the occludee.\n * @returns {Number} Visibility.NONE if the occludee is not visible,\n *                       Visibility.PARTIAL if the occludee is partially visible, or\n *                       Visibility.FULL if the occludee is fully visible.\n *\n *\n * @example\n * var sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * var sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE\n *\n * @see Occluder#isVisible\n */\n\nOccluder.prototype.computeVisibility = function (occludeeBS) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occludeeBS)) {\n    throw new DeveloperError(\"occludeeBS is required.\");\n  } //>>includeEnd('debug');\n  // If the occludee radius is larger than the occluders, this will return that\n  // the entire ocludee is visible, even though that may not be the case, though this should\n  // not occur too often.\n\n\n  var occludeePosition = Cartesian3.clone(occludeeBS.center);\n  var occludeeRadius = occludeeBS.radius;\n\n  if (occludeeRadius > this._occluderRadius) {\n    return Visibility.FULL;\n  }\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    // The camera is outside the occluder\n    var tempVec = Cartesian3.subtract(occludeePosition, this._occluderPosition, tempScratch);\n    var temp = this._occluderRadius - occludeeRadius;\n    var occluderToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n    temp = occluderToOccludeeDistSqrd - temp * temp;\n\n    if (temp > 0.0) {\n      // The occludee is not completely inside the occluder\n      // Check to see if the occluder completely hides the occludee\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludeePosition, this._cameraPosition, tempVec);\n      var cameraToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n\n      if (temp * temp + occludeeRadius * occludeeRadius < cameraToOccludeeDistSqrd) {\n        return Visibility.NONE;\n      } // Check to see whether the occluder is fully or partially visible\n      // when the occludee does not intersect the occluder\n\n\n      temp = this._occluderRadius + occludeeRadius;\n      temp = occluderToOccludeeDistSqrd - temp * temp;\n\n      if (temp > 0.0) {\n        // The occludee does not intersect the occluder.\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        return cameraToOccludeeDistSqrd < temp * temp + occludeeRadius * occludeeRadius ? Visibility.FULL : Visibility.PARTIAL;\n      } //Check to see if the occluder is fully or partially visible when the occludee DOES\n      //intersect the occluder\n\n\n      tempVec = Cartesian3.subtract(occludeePosition, this._horizonPlanePosition, tempVec);\n      return Cartesian3.dot(tempVec, this._horizonPlaneNormal) > -occludeeRadius ? Visibility.PARTIAL : Visibility.FULL;\n    }\n  }\n\n  return Visibility.NONE;\n};\n\nvar occludeePointScratch = new Cartesian3();\n/**\n * Computes a point that can be used as the occludee position to the visibility functions.\n * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around\n * an object that is used for visibility; however it is also possible to compute a point that if\n * seen/not seen would also indicate if an object is visible/not visible.  This function is better\n * called for objects that do not move relative to the occluder and is large, such as a chunk of\n * terrain.  You are better off not calling this and using the object's bounding sphere for objects\n * such as a satellite or ground vehicle.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.\n * @param {Cartesian3[]} positions List of altitude points on the horizon near the surface of the occluder.\n * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n *\n * @exception {DeveloperError} <code>positions</code> must contain at least one element.\n * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * var occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * var positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * var tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * var occludeePosition = tileOccluderSphere.center;\n * var occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);\n */\n\nOccluder.computeOccludeePoint = function (occluderBoundingSphere, occludeePosition, positions) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n\n  if (positions.length === 0) {\n    throw new DeveloperError(\"positions must contain at least one element\");\n  } //>>includeEnd('debug');\n\n\n  var occludeePos = Cartesian3.clone(occludeePosition);\n  var occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  var occluderRadius = occluderBoundingSphere.radius;\n  var numPositions = positions.length; //>>includeStart('debug', pragmas.debug);\n\n  if (Cartesian3.equals(occluderPosition, occludeePosition)) {\n    throw new DeveloperError(\"occludeePosition must be different than occluderBoundingSphere.center\");\n  } //>>includeEnd('debug');\n  // Compute a plane with a normal from the occluder to the occludee position.\n\n\n  var occluderPlaneNormal = Cartesian3.normalize(Cartesian3.subtract(occludeePos, occluderPosition, occludeePointScratch), occludeePointScratch);\n  var occluderPlaneD = -Cartesian3.dot(occluderPlaneNormal, occluderPosition); //For each position, determine the horizon intersection. Choose the position and intersection\n  //that results in the greatest angle with the occcluder plane.\n\n  var aRotationVector = Occluder._anyRotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD);\n\n  var dot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[0]);\n\n  if (!dot) {\n    //The position is inside the mimimum radius, which is invalid\n    return undefined;\n  }\n\n  var tempDot;\n\n  for (var i = 1; i < numPositions; ++i) {\n    tempDot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[i]);\n\n    if (!tempDot) {\n      //The position is inside the minimum radius, which is invalid\n      return undefined;\n    }\n\n    if (tempDot < dot) {\n      dot = tempDot;\n    }\n  } //Verify that the dot is not near 90 degress\n\n\n  if (dot < 0.00174532836589830883577820272085) {\n    return undefined;\n  }\n\n  var distance = occluderRadius / dot;\n  return Cartesian3.add(occluderPosition, Cartesian3.multiplyByScalar(occluderPlaneNormal, distance, occludeePointScratch), occludeePointScratch);\n};\n\nvar computeOccludeePointFromRectangleScratch = [];\n/**\n * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n */\n\nOccluder.computeOccludeePointFromRectangle = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  } //>>includeEnd('debug');\n\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var positions = Rectangle.subsample(rectangle, ellipsoid, 0.0, computeOccludeePointFromRectangleScratch);\n  var bs = BoundingSphere.fromPoints(positions); // TODO: get correct ellipsoid center\n\n  var ellipsoidCenter = Cartesian3.ZERO;\n\n  if (!Cartesian3.equals(ellipsoidCenter, bs.center)) {\n    return Occluder.computeOccludeePoint(new BoundingSphere(ellipsoidCenter, ellipsoid.minimumRadius), bs.center, positions);\n  }\n\n  return undefined;\n};\n\nvar tempVec0Scratch = new Cartesian3();\n\nOccluder._anyRotationVector = function (occluderPosition, occluderPlaneNormal, occluderPlaneD) {\n  var tempVec0 = Cartesian3.abs(occluderPlaneNormal, tempVec0Scratch);\n  var majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;\n\n  if (majorAxis === 0 && tempVec0.z > tempVec0.x || majorAxis === 1 && tempVec0.z > tempVec0.y) {\n    majorAxis = 2;\n  }\n\n  var tempVec = new Cartesian3();\n  var tempVec1;\n\n  if (majorAxis === 0) {\n    tempVec0.x = occluderPosition.x;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_X;\n  } else if (majorAxis === 1) {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_Y;\n  } else {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z;\n    tempVec1 = Cartesian3.UNIT_Z;\n  }\n\n  var u = (Cartesian3.dot(occluderPlaneNormal, tempVec0) + occluderPlaneD) / -Cartesian3.dot(occluderPlaneNormal, tempVec1);\n  return Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(tempVec0, Cartesian3.multiplyByScalar(tempVec1, u, tempVec), tempVec0), occluderPosition, tempVec0), tempVec0);\n};\n\nvar posDirectionScratch = new Cartesian3();\n\nOccluder._rotationVector = function (occluderPosition, occluderPlaneNormal, occluderPlaneD, position, anyRotationVector) {\n  //Determine the angle between the occluder plane normal and the position direction\n  var positionDirection = Cartesian3.subtract(position, occluderPosition, posDirectionScratch);\n  positionDirection = Cartesian3.normalize(positionDirection, positionDirection);\n\n  if (Cartesian3.dot(occluderPlaneNormal, positionDirection) < 0.99999998476912904932780850903444) {\n    var crossProduct = Cartesian3.cross(occluderPlaneNormal, positionDirection, positionDirection);\n    var length = Cartesian3.magnitude(crossProduct);\n\n    if (length > CesiumMath.EPSILON13) {\n      return Cartesian3.normalize(crossProduct, new Cartesian3());\n    }\n  } //The occluder plane normal and the position direction are colinear. Use any\n  //vector in the occluder plane as the rotation vector\n\n\n  return anyRotationVector;\n};\n\nvar posScratch1 = new Cartesian3();\nvar occluerPosScratch = new Cartesian3();\nvar posScratch2 = new Cartesian3();\nvar horizonPlanePosScratch = new Cartesian3();\n\nOccluder._horizonToPlaneNormalDotProduct = function (occluderBS, occluderPlaneNormal, occluderPlaneD, anyRotationVector, position) {\n  var pos = Cartesian3.clone(position, posScratch1);\n  var occluderPosition = Cartesian3.clone(occluderBS.center, occluerPosScratch);\n  var occluderRadius = occluderBS.radius; //Verify that the position is outside the occluder\n\n  var positionToOccluder = Cartesian3.subtract(occluderPosition, pos, posScratch2);\n  var occluderToPositionDistanceSquared = Cartesian3.magnitudeSquared(positionToOccluder);\n  var occluderRadiusSquared = occluderRadius * occluderRadius;\n\n  if (occluderToPositionDistanceSquared < occluderRadiusSquared) {\n    return false;\n  } //Horizon parameters\n\n\n  var horizonDistanceSquared = occluderToPositionDistanceSquared - occluderRadiusSquared;\n  var horizonDistance = Math.sqrt(horizonDistanceSquared);\n  var occluderToPositionDistance = Math.sqrt(occluderToPositionDistanceSquared);\n  var invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;\n  var cosTheta = horizonDistance * invOccluderToPositionDistance;\n  var horizonPlaneDistance = cosTheta * horizonDistance;\n  positionToOccluder = Cartesian3.normalize(positionToOccluder, positionToOccluder);\n  var horizonPlanePosition = Cartesian3.add(pos, Cartesian3.multiplyByScalar(positionToOccluder, horizonPlaneDistance, horizonPlanePosScratch), horizonPlanePosScratch);\n  var horizonCrossDistance = Math.sqrt(horizonDistanceSquared - horizonPlaneDistance * horizonPlaneDistance); //Rotate the position to occluder vector 90 degrees\n\n  var tempVec = this._rotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD, pos, anyRotationVector);\n\n  var horizonCrossDirection = Cartesian3.fromElements(tempVec.x * tempVec.x * positionToOccluder.x + (tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y + (tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z, (tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x + tempVec.y * tempVec.y * positionToOccluder.y + (tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z, (tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x + (tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y + tempVec.z * tempVec.z * positionToOccluder.z, posScratch1);\n  horizonCrossDirection = Cartesian3.normalize(horizonCrossDirection, horizonCrossDirection); //Horizon positions\n\n  var offset = Cartesian3.multiplyByScalar(horizonCrossDirection, horizonCrossDistance, posScratch1);\n  tempVec = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(horizonPlanePosition, offset, posScratch2), occluderPosition, posScratch2), posScratch2);\n  var dot0 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  tempVec = Cartesian3.normalize(Cartesian3.subtract(Cartesian3.subtract(horizonPlanePosition, offset, tempVec), occluderPosition, tempVec), tempVec);\n  var dot1 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  return dot0 < dot1 ? dot0 : dot1;\n};\n\nexport default Occluder;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/Occluder.js"],"names":["BoundingSphere","Cartesian3","defaultValue","defined","DeveloperError","Ellipsoid","CesiumMath","Rectangle","Visibility","Occluder","occluderBoundingSphere","cameraPosition","_occluderPosition","clone","center","_occluderRadius","radius","_horizonDistance","_horizonPlaneNormal","undefined","_horizonPlanePosition","_cameraPosition","scratchCartesian3","Object","defineProperties","prototype","position","get","set","cameraToOccluderVec","subtract","invCameraToOccluderDistance","magnitudeSquared","occluderRadiusSqrd","horizonDistance","horizonPlaneNormal","horizonPlanePosition","Math","sqrt","multiplyByScalar","nearPlaneDistance","add","Number","MAX_VALUE","fromBoundingSphere","result","tempVecScratch","isPointVisible","occludee","tempVec","temp","occludeePositionScratch","isBoundingSphereVisible","occludeePosition","occludeeRadius","tempVecMagnitudeSquared","occluderRadiusSquared","occludeeRadiusSquared","tempScratch","computeVisibility","occludeeBS","FULL","occluderToOccludeeDistSqrd","cameraToOccludeeDistSqrd","NONE","PARTIAL","dot","occludeePointScratch","computeOccludeePoint","positions","length","occludeePos","occluderPosition","occluderRadius","numPositions","equals","occluderPlaneNormal","normalize","occluderPlaneD","aRotationVector","_anyRotationVector","_horizonToPlaneNormalDotProduct","tempDot","i","distance","computeOccludeePointFromRectangleScratch","computeOccludeePointFromRectangle","rectangle","ellipsoid","WGS84","subsample","bs","fromPoints","ellipsoidCenter","ZERO","minimumRadius","tempVec0Scratch","tempVec0","abs","majorAxis","x","y","z","tempVec1","UNIT_X","UNIT_Y","UNIT_Z","u","posDirectionScratch","_rotationVector","anyRotationVector","positionDirection","crossProduct","cross","magnitude","EPSILON13","posScratch1","occluerPosScratch","posScratch2","horizonPlanePosScratch","occluderBS","pos","positionToOccluder","occluderToPositionDistanceSquared","horizonDistanceSquared","occluderToPositionDistance","invOccluderToPositionDistance","cosTheta","horizonPlaneDistance","horizonCrossDistance","horizonCrossDirection","fromElements","offset","dot0","dot1"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport CesiumMath from \"./Math.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Visibility from \"./Visibility.js\";\n\n/**\n * Creates an Occluder derived from an object's position and radius, as well as the camera position.\n * The occluder can be used to determine whether or not other objects are visible or hidden behind the\n * visible horizon defined by the occluder and camera position.\n *\n * @alias Occluder\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n *\n * @constructor\n *\n * @example\n * // Construct an occluder one unit away from the origin with a radius of one.\n * var cameraPosition = Cesium.Cartesian3.ZERO;\n * var occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);\n * var occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n */\nfunction Occluder(occluderBoundingSphere, cameraPosition) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  this._occluderRadius = occluderBoundingSphere.radius;\n\n  this._horizonDistance = 0.0;\n  this._horizonPlaneNormal = undefined;\n  this._horizonPlanePosition = undefined;\n  this._cameraPosition = undefined;\n\n  // cameraPosition fills in the above values\n  this.cameraPosition = cameraPosition;\n}\n\nvar scratchCartesian3 = new Cartesian3();\n\nObject.defineProperties(Occluder.prototype, {\n  /**\n   * The position of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  position: {\n    get: function () {\n      return this._occluderPosition;\n    },\n  },\n\n  /**\n   * The radius of the occluder.\n   * @memberof Occluder.prototype\n   * @type {Number}\n   */\n  radius: {\n    get: function () {\n      return this._occluderRadius;\n    },\n  },\n\n  /**\n   * The position of the camera.\n   * @memberof Occluder.prototype\n   * @type {Cartesian3}\n   */\n  cameraPosition: {\n    set: function (cameraPosition) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(cameraPosition)) {\n        throw new DeveloperError(\"cameraPosition is required.\");\n      }\n      //>>includeEnd('debug');\n\n      cameraPosition = Cartesian3.clone(cameraPosition, this._cameraPosition);\n\n      var cameraToOccluderVec = Cartesian3.subtract(\n        this._occluderPosition,\n        cameraPosition,\n        scratchCartesian3\n      );\n      var invCameraToOccluderDistance = Cartesian3.magnitudeSquared(\n        cameraToOccluderVec\n      );\n      var occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;\n\n      var horizonDistance;\n      var horizonPlaneNormal;\n      var horizonPlanePosition;\n      if (invCameraToOccluderDistance > occluderRadiusSqrd) {\n        horizonDistance = Math.sqrt(\n          invCameraToOccluderDistance - occluderRadiusSqrd\n        );\n        invCameraToOccluderDistance =\n          1.0 / Math.sqrt(invCameraToOccluderDistance);\n        horizonPlaneNormal = Cartesian3.multiplyByScalar(\n          cameraToOccluderVec,\n          invCameraToOccluderDistance,\n          scratchCartesian3\n        );\n        var nearPlaneDistance =\n          horizonDistance * horizonDistance * invCameraToOccluderDistance;\n        horizonPlanePosition = Cartesian3.add(\n          cameraPosition,\n          Cartesian3.multiplyByScalar(\n            horizonPlaneNormal,\n            nearPlaneDistance,\n            scratchCartesian3\n          ),\n          scratchCartesian3\n        );\n      } else {\n        horizonDistance = Number.MAX_VALUE;\n      }\n\n      this._horizonDistance = horizonDistance;\n      this._horizonPlaneNormal = horizonPlaneNormal;\n      this._horizonPlanePosition = horizonPlanePosition;\n      this._cameraPosition = cameraPosition;\n    },\n  },\n});\n\n/**\n * Creates an occluder from a bounding sphere and the camera position.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.\n * @param {Occluder} [result] The object onto which to store the result.\n * @returns {Occluder} The occluder derived from an object's position and radius, as well as the camera position.\n */\nOccluder.fromBoundingSphere = function (\n  occluderBoundingSphere,\n  cameraPosition,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n\n  if (!defined(cameraPosition)) {\n    throw new DeveloperError(\"camera position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Occluder(occluderBoundingSphere, cameraPosition);\n  }\n\n  Cartesian3.clone(occluderBoundingSphere.center, result._occluderPosition);\n  result._occluderRadius = occluderBoundingSphere.radius;\n  result.cameraPosition = cameraPosition;\n\n  return result;\n};\n\nvar tempVecScratch = new Cartesian3();\n\n/**\n * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {Cartesian3} occludee The point surrounding the occludee object.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * var occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * var point = new Cesium.Cartesian3(0, 0, -3);\n * occluder.isPointVisible(point); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isPointVisible = function (occludee) {\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    var tempVec = Cartesian3.subtract(\n      occludee,\n      this._occluderPosition,\n      tempVecScratch\n    );\n    var temp = this._occluderRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (temp > 0.0) {\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(occludee, this._cameraPosition, tempVec);\n      return temp * temp > Cartesian3.magnitudeSquared(tempVec);\n    }\n  }\n  return false;\n};\n\nvar occludeePositionScratch = new Cartesian3();\n\n/**\n * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.\n *\n * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.\n * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.\n *\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);\n * var occluder = new Cesium.Occluder(littleSphere, cameraPosition);\n * var bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);\n * occluder.isBoundingSphereVisible(bigSphere); //returns true\n *\n * @see Occluder#computeVisibility\n */\nOccluder.prototype.isBoundingSphereVisible = function (occludee) {\n  var occludeePosition = Cartesian3.clone(\n    occludee.center,\n    occludeePositionScratch\n  );\n  var occludeeRadius = occludee.radius;\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    var tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempVecScratch\n    );\n    var temp = this._occluderRadius - occludeeRadius;\n    temp = Cartesian3.magnitudeSquared(tempVec) - temp * temp;\n    if (occludeeRadius < this._occluderRadius) {\n      if (temp > 0.0) {\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        tempVec = Cartesian3.subtract(\n          occludeePosition,\n          this._cameraPosition,\n          tempVec\n        );\n        return (\n          temp * temp + occludeeRadius * occludeeRadius >\n          Cartesian3.magnitudeSquared(tempVec)\n        );\n      }\n      return false;\n    }\n\n    // Prevent against the case where the occludee radius is larger than the occluder's; since this is\n    // an uncommon case, the following code should rarely execute.\n    if (temp > 0.0) {\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec\n      );\n      var tempVecMagnitudeSquared = Cartesian3.magnitudeSquared(tempVec);\n      var occluderRadiusSquared = this._occluderRadius * this._occluderRadius;\n      var occludeeRadiusSquared = occludeeRadius * occludeeRadius;\n      if (\n        (this._horizonDistance * this._horizonDistance +\n          occluderRadiusSquared) *\n          occludeeRadiusSquared >\n        tempVecMagnitudeSquared * occluderRadiusSquared\n      ) {\n        // The occludee is close enough that the occluder cannot possible occlude the occludee\n        return true;\n      }\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      return temp * temp + occludeeRadiusSquared > tempVecMagnitudeSquared;\n    }\n\n    // The occludee completely encompasses the occluder\n    return true;\n  }\n\n  return false;\n};\n\nvar tempScratch = new Cartesian3();\n/**\n * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).\n *\n * @param {BoundingSphere} occludeeBS The bounding sphere of the occludee.\n * @returns {Number} Visibility.NONE if the occludee is not visible,\n *                       Visibility.PARTIAL if the occludee is partially visible, or\n *                       Visibility.FULL if the occludee is fully visible.\n *\n *\n * @example\n * var sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);\n * var sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var occluder = new Cesium.Occluder(sphere1, cameraPosition);\n * occluder.computeVisibility(sphere2); //returns Visibility.NONE\n *\n * @see Occluder#isVisible\n */\nOccluder.prototype.computeVisibility = function (occludeeBS) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occludeeBS)) {\n    throw new DeveloperError(\"occludeeBS is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // If the occludee radius is larger than the occluders, this will return that\n  // the entire ocludee is visible, even though that may not be the case, though this should\n  // not occur too often.\n  var occludeePosition = Cartesian3.clone(occludeeBS.center);\n  var occludeeRadius = occludeeBS.radius;\n\n  if (occludeeRadius > this._occluderRadius) {\n    return Visibility.FULL;\n  }\n\n  if (this._horizonDistance !== Number.MAX_VALUE) {\n    // The camera is outside the occluder\n    var tempVec = Cartesian3.subtract(\n      occludeePosition,\n      this._occluderPosition,\n      tempScratch\n    );\n    var temp = this._occluderRadius - occludeeRadius;\n    var occluderToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n    temp = occluderToOccludeeDistSqrd - temp * temp;\n    if (temp > 0.0) {\n      // The occludee is not completely inside the occluder\n      // Check to see if the occluder completely hides the occludee\n      temp = Math.sqrt(temp) + this._horizonDistance;\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._cameraPosition,\n        tempVec\n      );\n      var cameraToOccludeeDistSqrd = Cartesian3.magnitudeSquared(tempVec);\n      if (\n        temp * temp + occludeeRadius * occludeeRadius <\n        cameraToOccludeeDistSqrd\n      ) {\n        return Visibility.NONE;\n      }\n\n      // Check to see whether the occluder is fully or partially visible\n      // when the occludee does not intersect the occluder\n      temp = this._occluderRadius + occludeeRadius;\n      temp = occluderToOccludeeDistSqrd - temp * temp;\n      if (temp > 0.0) {\n        // The occludee does not intersect the occluder.\n        temp = Math.sqrt(temp) + this._horizonDistance;\n        return cameraToOccludeeDistSqrd <\n          temp * temp + occludeeRadius * occludeeRadius\n          ? Visibility.FULL\n          : Visibility.PARTIAL;\n      }\n\n      //Check to see if the occluder is fully or partially visible when the occludee DOES\n      //intersect the occluder\n      tempVec = Cartesian3.subtract(\n        occludeePosition,\n        this._horizonPlanePosition,\n        tempVec\n      );\n      return Cartesian3.dot(tempVec, this._horizonPlaneNormal) > -occludeeRadius\n        ? Visibility.PARTIAL\n        : Visibility.FULL;\n    }\n  }\n  return Visibility.NONE;\n};\n\nvar occludeePointScratch = new Cartesian3();\n/**\n * Computes a point that can be used as the occludee position to the visibility functions.\n * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around\n * an object that is used for visibility; however it is also possible to compute a point that if\n * seen/not seen would also indicate if an object is visible/not visible.  This function is better\n * called for objects that do not move relative to the occluder and is large, such as a chunk of\n * terrain.  You are better off not calling this and using the object's bounding sphere for objects\n * such as a satellite or ground vehicle.\n *\n * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.\n * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.\n * @param {Cartesian3[]} positions List of altitude points on the horizon near the surface of the occluder.\n * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n *\n * @exception {DeveloperError} <code>positions</code> must contain at least one element.\n * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.\n *\n * @example\n * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);\n * var occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);\n * var occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);\n * var positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];\n * var tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);\n * var occludeePosition = tileOccluderSphere.center;\n * var occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);\n */\nOccluder.computeOccludeePoint = function (\n  occluderBoundingSphere,\n  occludeePosition,\n  positions\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(occluderBoundingSphere)) {\n    throw new DeveloperError(\"occluderBoundingSphere is required.\");\n  }\n  if (!defined(positions)) {\n    throw new DeveloperError(\"positions is required.\");\n  }\n  if (positions.length === 0) {\n    throw new DeveloperError(\"positions must contain at least one element\");\n  }\n  //>>includeEnd('debug');\n\n  var occludeePos = Cartesian3.clone(occludeePosition);\n  var occluderPosition = Cartesian3.clone(occluderBoundingSphere.center);\n  var occluderRadius = occluderBoundingSphere.radius;\n  var numPositions = positions.length;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (Cartesian3.equals(occluderPosition, occludeePosition)) {\n    throw new DeveloperError(\n      \"occludeePosition must be different than occluderBoundingSphere.center\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  // Compute a plane with a normal from the occluder to the occludee position.\n  var occluderPlaneNormal = Cartesian3.normalize(\n    Cartesian3.subtract(occludeePos, occluderPosition, occludeePointScratch),\n    occludeePointScratch\n  );\n  var occluderPlaneD = -Cartesian3.dot(occluderPlaneNormal, occluderPosition);\n\n  //For each position, determine the horizon intersection. Choose the position and intersection\n  //that results in the greatest angle with the occcluder plane.\n  var aRotationVector = Occluder._anyRotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD\n  );\n  var dot = Occluder._horizonToPlaneNormalDotProduct(\n    occluderBoundingSphere,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    aRotationVector,\n    positions[0]\n  );\n  if (!dot) {\n    //The position is inside the mimimum radius, which is invalid\n    return undefined;\n  }\n  var tempDot;\n  for (var i = 1; i < numPositions; ++i) {\n    tempDot = Occluder._horizonToPlaneNormalDotProduct(\n      occluderBoundingSphere,\n      occluderPlaneNormal,\n      occluderPlaneD,\n      aRotationVector,\n      positions[i]\n    );\n    if (!tempDot) {\n      //The position is inside the minimum radius, which is invalid\n      return undefined;\n    }\n    if (tempDot < dot) {\n      dot = tempDot;\n    }\n  }\n  //Verify that the dot is not near 90 degress\n  if (dot < 0.00174532836589830883577820272085) {\n    return undefined;\n  }\n\n  var distance = occluderRadius / dot;\n  return Cartesian3.add(\n    occluderPosition,\n    Cartesian3.multiplyByScalar(\n      occluderPlaneNormal,\n      distance,\n      occludeePointScratch\n    ),\n    occludeePointScratch\n  );\n};\n\nvar computeOccludeePointFromRectangleScratch = [];\n/**\n * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.\n *\n * @param {Rectangle} rectangle The rectangle used to create a bounding sphere.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>\n * which is a boolean value.\n */\nOccluder.computeOccludeePointFromRectangle = function (rectangle, ellipsoid) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required.\");\n  }\n  //>>includeEnd('debug');\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var positions = Rectangle.subsample(\n    rectangle,\n    ellipsoid,\n    0.0,\n    computeOccludeePointFromRectangleScratch\n  );\n  var bs = BoundingSphere.fromPoints(positions);\n\n  // TODO: get correct ellipsoid center\n  var ellipsoidCenter = Cartesian3.ZERO;\n  if (!Cartesian3.equals(ellipsoidCenter, bs.center)) {\n    return Occluder.computeOccludeePoint(\n      new BoundingSphere(ellipsoidCenter, ellipsoid.minimumRadius),\n      bs.center,\n      positions\n    );\n  }\n\n  return undefined;\n};\n\nvar tempVec0Scratch = new Cartesian3();\nOccluder._anyRotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD\n) {\n  var tempVec0 = Cartesian3.abs(occluderPlaneNormal, tempVec0Scratch);\n  var majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;\n  if (\n    (majorAxis === 0 && tempVec0.z > tempVec0.x) ||\n    (majorAxis === 1 && tempVec0.z > tempVec0.y)\n  ) {\n    majorAxis = 2;\n  }\n  var tempVec = new Cartesian3();\n  var tempVec1;\n  if (majorAxis === 0) {\n    tempVec0.x = occluderPosition.x;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_X;\n  } else if (majorAxis === 1) {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y;\n    tempVec0.z = occluderPosition.z + 1.0;\n    tempVec1 = Cartesian3.UNIT_Y;\n  } else {\n    tempVec0.x = occluderPosition.x + 1.0;\n    tempVec0.y = occluderPosition.y + 1.0;\n    tempVec0.z = occluderPosition.z;\n    tempVec1 = Cartesian3.UNIT_Z;\n  }\n  var u =\n    (Cartesian3.dot(occluderPlaneNormal, tempVec0) + occluderPlaneD) /\n    -Cartesian3.dot(occluderPlaneNormal, tempVec1);\n  return Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(\n        tempVec0,\n        Cartesian3.multiplyByScalar(tempVec1, u, tempVec),\n        tempVec0\n      ),\n      occluderPosition,\n      tempVec0\n    ),\n    tempVec0\n  );\n};\n\nvar posDirectionScratch = new Cartesian3();\nOccluder._rotationVector = function (\n  occluderPosition,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  position,\n  anyRotationVector\n) {\n  //Determine the angle between the occluder plane normal and the position direction\n  var positionDirection = Cartesian3.subtract(\n    position,\n    occluderPosition,\n    posDirectionScratch\n  );\n  positionDirection = Cartesian3.normalize(\n    positionDirection,\n    positionDirection\n  );\n  if (\n    Cartesian3.dot(occluderPlaneNormal, positionDirection) <\n    0.99999998476912904932780850903444\n  ) {\n    var crossProduct = Cartesian3.cross(\n      occluderPlaneNormal,\n      positionDirection,\n      positionDirection\n    );\n    var length = Cartesian3.magnitude(crossProduct);\n    if (length > CesiumMath.EPSILON13) {\n      return Cartesian3.normalize(crossProduct, new Cartesian3());\n    }\n  }\n  //The occluder plane normal and the position direction are colinear. Use any\n  //vector in the occluder plane as the rotation vector\n  return anyRotationVector;\n};\n\nvar posScratch1 = new Cartesian3();\nvar occluerPosScratch = new Cartesian3();\nvar posScratch2 = new Cartesian3();\nvar horizonPlanePosScratch = new Cartesian3();\nOccluder._horizonToPlaneNormalDotProduct = function (\n  occluderBS,\n  occluderPlaneNormal,\n  occluderPlaneD,\n  anyRotationVector,\n  position\n) {\n  var pos = Cartesian3.clone(position, posScratch1);\n  var occluderPosition = Cartesian3.clone(occluderBS.center, occluerPosScratch);\n  var occluderRadius = occluderBS.radius;\n\n  //Verify that the position is outside the occluder\n  var positionToOccluder = Cartesian3.subtract(\n    occluderPosition,\n    pos,\n    posScratch2\n  );\n  var occluderToPositionDistanceSquared = Cartesian3.magnitudeSquared(\n    positionToOccluder\n  );\n  var occluderRadiusSquared = occluderRadius * occluderRadius;\n  if (occluderToPositionDistanceSquared < occluderRadiusSquared) {\n    return false;\n  }\n\n  //Horizon parameters\n  var horizonDistanceSquared =\n    occluderToPositionDistanceSquared - occluderRadiusSquared;\n  var horizonDistance = Math.sqrt(horizonDistanceSquared);\n  var occluderToPositionDistance = Math.sqrt(occluderToPositionDistanceSquared);\n  var invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;\n  var cosTheta = horizonDistance * invOccluderToPositionDistance;\n  var horizonPlaneDistance = cosTheta * horizonDistance;\n  positionToOccluder = Cartesian3.normalize(\n    positionToOccluder,\n    positionToOccluder\n  );\n  var horizonPlanePosition = Cartesian3.add(\n    pos,\n    Cartesian3.multiplyByScalar(\n      positionToOccluder,\n      horizonPlaneDistance,\n      horizonPlanePosScratch\n    ),\n    horizonPlanePosScratch\n  );\n  var horizonCrossDistance = Math.sqrt(\n    horizonDistanceSquared - horizonPlaneDistance * horizonPlaneDistance\n  );\n\n  //Rotate the position to occluder vector 90 degrees\n  var tempVec = this._rotationVector(\n    occluderPosition,\n    occluderPlaneNormal,\n    occluderPlaneD,\n    pos,\n    anyRotationVector\n  );\n  var horizonCrossDirection = Cartesian3.fromElements(\n    tempVec.x * tempVec.x * positionToOccluder.x +\n      (tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y +\n      (tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z,\n    (tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x +\n      tempVec.y * tempVec.y * positionToOccluder.y +\n      (tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z,\n    (tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x +\n      (tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y +\n      tempVec.z * tempVec.z * positionToOccluder.z,\n    posScratch1\n  );\n  horizonCrossDirection = Cartesian3.normalize(\n    horizonCrossDirection,\n    horizonCrossDirection\n  );\n\n  //Horizon positions\n  var offset = Cartesian3.multiplyByScalar(\n    horizonCrossDirection,\n    horizonCrossDistance,\n    posScratch1\n  );\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.add(horizonPlanePosition, offset, posScratch2),\n      occluderPosition,\n      posScratch2\n    ),\n    posScratch2\n  );\n  var dot0 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  tempVec = Cartesian3.normalize(\n    Cartesian3.subtract(\n      Cartesian3.subtract(horizonPlanePosition, offset, tempVec),\n      occluderPosition,\n      tempVec\n    ),\n    tempVec\n  );\n  var dot1 = Cartesian3.dot(occluderPlaneNormal, tempVec);\n  return dot0 < dot1 ? dot0 : dot1;\n};\nexport default Occluder;\n"]},"metadata":{},"sourceType":"module"}