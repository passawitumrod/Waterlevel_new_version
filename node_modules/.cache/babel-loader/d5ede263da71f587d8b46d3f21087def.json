{"ast":null,"code":"import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport EventHelper from \"../Core/EventHelper.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport BoxGeometryUpdater from \"./BoxGeometryUpdater.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport CorridorGeometryUpdater from \"./CorridorGeometryUpdater.js\";\nimport CylinderGeometryUpdater from \"./CylinderGeometryUpdater.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport EllipseGeometryUpdater from \"./EllipseGeometryUpdater.js\";\nimport EllipsoidGeometryUpdater from \"./EllipsoidGeometryUpdater.js\";\nimport Entity from \"./Entity.js\";\nimport PlaneGeometryUpdater from \"./PlaneGeometryUpdater.js\";\nimport PolygonGeometryUpdater from \"./PolygonGeometryUpdater.js\";\nimport PolylineVolumeGeometryUpdater from \"./PolylineVolumeGeometryUpdater.js\";\nimport RectangleGeometryUpdater from \"./RectangleGeometryUpdater.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundGeometryColorBatch from \"./StaticGroundGeometryColorBatch.js\";\nimport StaticGroundGeometryPerMaterialBatch from \"./StaticGroundGeometryPerMaterialBatch.js\";\nimport StaticOutlineGeometryBatch from \"./StaticOutlineGeometryBatch.js\";\nimport WallGeometryUpdater from \"./WallGeometryUpdater.js\";\nvar emptyArray = [];\nvar geometryUpdaters = [BoxGeometryUpdater, CylinderGeometryUpdater, CorridorGeometryUpdater, EllipseGeometryUpdater, EllipsoidGeometryUpdater, PlaneGeometryUpdater, PolygonGeometryUpdater, PolylineVolumeGeometryUpdater, RectangleGeometryUpdater, WallGeometryUpdater];\n\nfunction GeometryUpdaterSet(entity, scene) {\n  this.entity = entity;\n  this.scene = scene;\n  var updaters = new Array(geometryUpdaters.length);\n  var geometryChanged = new Event();\n\n  function raiseEvent(geometry) {\n    geometryChanged.raiseEvent(geometry);\n  }\n\n  var eventHelper = new EventHelper();\n\n  for (var i = 0; i < updaters.length; i++) {\n    var updater = new geometryUpdaters[i](entity, scene);\n    eventHelper.add(updater.geometryChanged, raiseEvent);\n    updaters[i] = updater;\n  }\n\n  this.updaters = updaters;\n  this.geometryChanged = geometryChanged;\n  this.eventHelper = eventHelper;\n  this._removeEntitySubscription = entity.definitionChanged.addEventListener(GeometryUpdaterSet.prototype._onEntityPropertyChanged, this);\n}\n\nGeometryUpdaterSet.prototype._onEntityPropertyChanged = function (entity, propertyName, newValue, oldValue) {\n  var updaters = this.updaters;\n\n  for (var i = 0; i < updaters.length; i++) {\n    updaters[i]._onEntityPropertyChanged(entity, propertyName, newValue, oldValue);\n  }\n};\n\nGeometryUpdaterSet.prototype.forEach = function (callback) {\n  var updaters = this.updaters;\n\n  for (var i = 0; i < updaters.length; i++) {\n    callback(updaters[i]);\n  }\n};\n\nGeometryUpdaterSet.prototype.destroy = function () {\n  this.eventHelper.removeAll();\n  var updaters = this.updaters;\n\n  for (var i = 0; i < updaters.length; i++) {\n    updaters[i].destroy();\n  }\n\n  this._removeEntitySubscription();\n\n  destroyObject(this);\n};\n/**\n * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n * @alias GeometryVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\n\n\nfunction GeometryVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection); //>>includeEnd('debug');\n\n  primitives = defaultValue(primitives, scene.primitives);\n  groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n  this._scene = scene;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n  var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._outlineBatches = new Array(numberOfShadowModes * 2);\n  this._closedColorBatches = new Array(numberOfShadowModes * 2);\n  this._closedMaterialBatches = new Array(numberOfShadowModes * 2);\n  this._openColorBatches = new Array(numberOfShadowModes * 2);\n  this._openMaterialBatches = new Array(numberOfShadowModes * 2);\n  var supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(scene);\n  this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;\n  var i;\n\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._outlineBatches[i] = new StaticOutlineGeometryBatch(primitives, scene, i, false);\n    this._outlineBatches[numberOfShadowModes + i] = new StaticOutlineGeometryBatch(primitives, scene, i, true);\n    this._closedColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, true);\n    this._closedColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, false);\n    this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, true);\n    this._closedMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, false);\n    this._openColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, true);\n    this._openColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, false);\n    this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, true);\n    this._openMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, false);\n  }\n\n  var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  var groundColorBatches = new Array(numberOfClassificationTypes);\n  var groundMaterialBatches = [];\n\n  if (supportsMaterialsforEntitiesOnTerrain) {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundMaterialBatches.push(new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, MaterialAppearance));\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n    }\n  } else {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n    }\n  }\n\n  this._groundColorBatches = groundColorBatches;\n  this._groundMaterialBatches = groundMaterialBatches;\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n  this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch);\n  this._subscriptions = new AssociativeArray();\n  this._updaterSets = new AssociativeArray();\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n\n  this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n}\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\n\n\nGeometryVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time); //>>includeEnd('debug');\n\n  var addedObjects = this._addedObjects;\n  var added = addedObjects.values;\n  var removedObjects = this._removedObjects;\n  var removed = removedObjects.values;\n  var changedObjects = this._changedObjects;\n  var changed = changedObjects.values;\n  var i;\n  var entity;\n  var id;\n  var updaterSet;\n  var that = this;\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id); //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n\n    if (updaterSet.entity === entity) {\n      updaterSet.forEach(function (updater) {\n        that._removeUpdater(updater);\n\n        that._insertUpdaterIntoBatch(time, updater);\n      });\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id);\n    updaterSet.forEach(this._removeUpdater.bind(this));\n    updaterSet.destroy();\n\n    this._updaterSets.remove(id);\n\n    this._subscriptions.get(id)();\n\n    this._subscriptions.remove(id);\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updaterSet = new GeometryUpdaterSet(entity, this._scene);\n\n    this._updaterSets.set(id, updaterSet);\n\n    updaterSet.forEach(function (updater) {\n      that._insertUpdaterIntoBatch(time, updater);\n    });\n\n    this._subscriptions.set(id, updaterSet.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));\n  }\n\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n  var isUpdated = true;\n  var batches = this._batches;\n  var length = batches.length;\n\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  return isUpdated;\n};\n\nvar getBoundingSphereArrayScratch = [];\nvar getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\n\nGeometryVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result); //>>includeEnd('debug');\n\n  var boundingSpheres = getBoundingSphereArrayScratch;\n  var tmp = getBoundingSphereBoundingSphereScratch;\n  var count = 0;\n  var state = BoundingSphereState.DONE;\n  var batches = this._batches;\n  var batchesLength = batches.length;\n  var id = entity.id;\n\n  var updaters = this._updaterSets.get(id).updaters;\n\n  for (var j = 0; j < updaters.length; j++) {\n    var updater = updaters[j];\n\n    for (var i = 0; i < batchesLength; i++) {\n      state = batches[i].getBoundingSphere(updater, tmp);\n\n      if (state === BoundingSphereState.PENDING) {\n        return BoundingSphereState.PENDING;\n      } else if (state === BoundingSphereState.DONE) {\n        boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n        count++;\n      }\n    }\n  }\n\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\n\n\nGeometryVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Removes and destroys all primitives created by this instance.\n */\n\n\nGeometryVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n\n  this._addedObjects.removeAll();\n\n  this._removedObjects.removeAll();\n\n  var i;\n  var batches = this._batches;\n  var length = batches.length;\n\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n\n  var subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n\n  this._subscriptions.removeAll();\n\n  var updaterSets = this._updaterSets.values;\n  length = updaterSets.length;\n\n  for (i = 0; i < length; i++) {\n    updaterSets[i].destroy();\n  }\n\n  this._updaterSets.removeAll();\n\n  return destroyObject(this);\n};\n/**\n * @private\n */\n\n\nGeometryVisualizer.prototype._removeUpdater = function (updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  var batches = this._batches;\n  var length = batches.length;\n\n  for (var i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n};\n/**\n * @private\n */\n\n\nGeometryVisualizer.prototype._insertUpdaterIntoBatch = function (time, updater) {\n  if (updater.isDynamic) {\n    this._dynamicBatch.add(time, updater);\n\n    return;\n  }\n\n  var shadows;\n\n  if (updater.outlineEnabled || updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n\n  var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n\n  if (updater.outlineEnabled) {\n    if (defined(updater.terrainOffsetProperty)) {\n      this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n    } else {\n      this._outlineBatches[shadows].add(time, updater);\n    }\n  }\n\n  if (updater.fillEnabled) {\n    if (updater.onTerrain) {\n      var classificationType = updater.classificationTypeProperty.getValue(time);\n\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        this._groundColorBatches[classificationType].add(time, updater);\n      } else {\n        // If unsupported, updater will not be on terrain.\n        this._groundMaterialBatches[classificationType].add(time, updater);\n      }\n    } else if (updater.isClosed) {\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        if (defined(updater.terrainOffsetProperty)) {\n          this._closedColorBatches[numberOfShadowModes + shadows].add(time, updater);\n        } else {\n          this._closedColorBatches[shadows].add(time, updater);\n        }\n      } else if (defined(updater.terrainOffsetProperty)) {\n        this._closedMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n      } else {\n        this._closedMaterialBatches[shadows].add(time, updater);\n      }\n    } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      if (defined(updater.terrainOffsetProperty)) {\n        this._openColorBatches[numberOfShadowModes + shadows].add(time, updater);\n      } else {\n        this._openColorBatches[shadows].add(time, updater);\n      }\n    } else if (defined(updater.terrainOffsetProperty)) {\n      this._openMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n    } else {\n      this._openMaterialBatches[shadows].add(time, updater);\n    }\n  }\n};\n/**\n * @private\n */\n\n\nGeometryVisualizer._onGeometryChanged = function (updater) {\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n  var entity = updater.entity;\n  var id = entity.id;\n\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n/**\n * @private\n */\n\n\nGeometryVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed) {\n  var addedObjects = this._addedObjects;\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n  var i;\n  var id;\n  var entity;\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\n\nexport default GeometryVisualizer;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/DataSources/GeometryVisualizer.js"],"names":["AssociativeArray","BoundingSphere","Check","defaultValue","defined","destroyObject","Event","EventHelper","ClassificationType","MaterialAppearance","PerInstanceColorAppearance","ShadowMode","BoundingSphereState","BoxGeometryUpdater","ColorMaterialProperty","CorridorGeometryUpdater","CylinderGeometryUpdater","DynamicGeometryBatch","EllipseGeometryUpdater","EllipsoidGeometryUpdater","Entity","PlaneGeometryUpdater","PolygonGeometryUpdater","PolylineVolumeGeometryUpdater","RectangleGeometryUpdater","StaticGeometryColorBatch","StaticGeometryPerMaterialBatch","StaticGroundGeometryColorBatch","StaticGroundGeometryPerMaterialBatch","StaticOutlineGeometryBatch","WallGeometryUpdater","emptyArray","geometryUpdaters","GeometryUpdaterSet","entity","scene","updaters","Array","length","geometryChanged","raiseEvent","geometry","eventHelper","i","updater","add","_removeEntitySubscription","definitionChanged","addEventListener","prototype","_onEntityPropertyChanged","propertyName","newValue","oldValue","forEach","callback","destroy","removeAll","GeometryVisualizer","entityCollection","primitives","groundPrimitives","_scene","_primitives","_groundPrimitives","_entityCollection","undefined","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","NUMBER_OF_SHADOW_MODES","_outlineBatches","_closedColorBatches","_closedMaterialBatches","_openColorBatches","_openMaterialBatches","supportsMaterialsforEntitiesOnTerrain","_supportsMaterialsforEntitiesOnTerrain","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","groundColorBatches","groundMaterialBatches","push","_groundColorBatches","_groundMaterialBatches","_dynamicBatch","_batches","concat","_subscriptions","_updaterSets","collectionChanged","_onCollectionChanged","values","update","time","addedObjects","added","removedObjects","removed","changedObjects","changed","id","updaterSet","that","get","_removeUpdater","_insertUpdaterIntoBatch","bind","remove","set","_onGeometryChanged","isUpdated","batches","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","getBoundingSphere","result","boundingSpheres","tmp","count","state","DONE","batchesLength","j","PENDING","clone","FAILED","fromBoundingSpheres","isDestroyed","removeEventListener","removeAllPrimitives","subscriptions","updaterSets","isDynamic","shadows","outlineEnabled","fillEnabled","shadowsProperty","getValue","terrainOffsetProperty","onTerrain","classificationType","classificationTypeProperty","fillMaterialProperty","isClosed"],"mappings":"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","sourcesContent":["import AssociativeArray from \"../Core/AssociativeArray.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Event from \"../Core/Event.js\";\nimport EventHelper from \"../Core/EventHelper.js\";\nimport ClassificationType from \"../Scene/ClassificationType.js\";\nimport MaterialAppearance from \"../Scene/MaterialAppearance.js\";\nimport PerInstanceColorAppearance from \"../Scene/PerInstanceColorAppearance.js\";\nimport ShadowMode from \"../Scene/ShadowMode.js\";\nimport BoundingSphereState from \"./BoundingSphereState.js\";\nimport BoxGeometryUpdater from \"./BoxGeometryUpdater.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport CorridorGeometryUpdater from \"./CorridorGeometryUpdater.js\";\nimport CylinderGeometryUpdater from \"./CylinderGeometryUpdater.js\";\nimport DynamicGeometryBatch from \"./DynamicGeometryBatch.js\";\nimport EllipseGeometryUpdater from \"./EllipseGeometryUpdater.js\";\nimport EllipsoidGeometryUpdater from \"./EllipsoidGeometryUpdater.js\";\nimport Entity from \"./Entity.js\";\nimport PlaneGeometryUpdater from \"./PlaneGeometryUpdater.js\";\nimport PolygonGeometryUpdater from \"./PolygonGeometryUpdater.js\";\nimport PolylineVolumeGeometryUpdater from \"./PolylineVolumeGeometryUpdater.js\";\nimport RectangleGeometryUpdater from \"./RectangleGeometryUpdater.js\";\nimport StaticGeometryColorBatch from \"./StaticGeometryColorBatch.js\";\nimport StaticGeometryPerMaterialBatch from \"./StaticGeometryPerMaterialBatch.js\";\nimport StaticGroundGeometryColorBatch from \"./StaticGroundGeometryColorBatch.js\";\nimport StaticGroundGeometryPerMaterialBatch from \"./StaticGroundGeometryPerMaterialBatch.js\";\nimport StaticOutlineGeometryBatch from \"./StaticOutlineGeometryBatch.js\";\nimport WallGeometryUpdater from \"./WallGeometryUpdater.js\";\n\nvar emptyArray = [];\n\nvar geometryUpdaters = [\n  BoxGeometryUpdater,\n  CylinderGeometryUpdater,\n  CorridorGeometryUpdater,\n  EllipseGeometryUpdater,\n  EllipsoidGeometryUpdater,\n  PlaneGeometryUpdater,\n  PolygonGeometryUpdater,\n  PolylineVolumeGeometryUpdater,\n  RectangleGeometryUpdater,\n  WallGeometryUpdater,\n];\n\nfunction GeometryUpdaterSet(entity, scene) {\n  this.entity = entity;\n  this.scene = scene;\n  var updaters = new Array(geometryUpdaters.length);\n  var geometryChanged = new Event();\n  function raiseEvent(geometry) {\n    geometryChanged.raiseEvent(geometry);\n  }\n  var eventHelper = new EventHelper();\n  for (var i = 0; i < updaters.length; i++) {\n    var updater = new geometryUpdaters[i](entity, scene);\n    eventHelper.add(updater.geometryChanged, raiseEvent);\n    updaters[i] = updater;\n  }\n  this.updaters = updaters;\n  this.geometryChanged = geometryChanged;\n  this.eventHelper = eventHelper;\n\n  this._removeEntitySubscription = entity.definitionChanged.addEventListener(\n    GeometryUpdaterSet.prototype._onEntityPropertyChanged,\n    this\n  );\n}\n\nGeometryUpdaterSet.prototype._onEntityPropertyChanged = function (\n  entity,\n  propertyName,\n  newValue,\n  oldValue\n) {\n  var updaters = this.updaters;\n  for (var i = 0; i < updaters.length; i++) {\n    updaters[i]._onEntityPropertyChanged(\n      entity,\n      propertyName,\n      newValue,\n      oldValue\n    );\n  }\n};\n\nGeometryUpdaterSet.prototype.forEach = function (callback) {\n  var updaters = this.updaters;\n  for (var i = 0; i < updaters.length; i++) {\n    callback(updaters[i]);\n  }\n};\n\nGeometryUpdaterSet.prototype.destroy = function () {\n  this.eventHelper.removeAll();\n  var updaters = this.updaters;\n  for (var i = 0; i < updaters.length; i++) {\n    updaters[i].destroy();\n  }\n  this._removeEntitySubscription();\n  destroyObject(this);\n};\n\n/**\n * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n * @alias GeometryVisualizer\n * @constructor\n *\n * @param {Scene} scene The scene the primitives will be rendered in.\n * @param {EntityCollection} entityCollection The entityCollection to visualize.\n * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n */\nfunction GeometryVisualizer(\n  scene,\n  entityCollection,\n  primitives,\n  groundPrimitives\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"scene\", scene);\n  Check.defined(\"entityCollection\", entityCollection);\n  //>>includeEnd('debug');\n\n  primitives = defaultValue(primitives, scene.primitives);\n  groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n\n  this._scene = scene;\n  this._primitives = primitives;\n  this._groundPrimitives = groundPrimitives;\n  this._entityCollection = undefined;\n  this._addedObjects = new AssociativeArray();\n  this._removedObjects = new AssociativeArray();\n  this._changedObjects = new AssociativeArray();\n\n  var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  this._outlineBatches = new Array(numberOfShadowModes * 2);\n  this._closedColorBatches = new Array(numberOfShadowModes * 2);\n  this._closedMaterialBatches = new Array(numberOfShadowModes * 2);\n  this._openColorBatches = new Array(numberOfShadowModes * 2);\n  this._openMaterialBatches = new Array(numberOfShadowModes * 2);\n\n  var supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(\n    scene\n  );\n  this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;\n\n  var i;\n  for (i = 0; i < numberOfShadowModes; ++i) {\n    this._outlineBatches[i] = new StaticOutlineGeometryBatch(\n      primitives,\n      scene,\n      i,\n      false\n    );\n    this._outlineBatches[\n      numberOfShadowModes + i\n    ] = new StaticOutlineGeometryBatch(primitives, scene, i, true);\n\n    this._closedColorBatches[i] = new StaticGeometryColorBatch(\n      primitives,\n      PerInstanceColorAppearance,\n      undefined,\n      true,\n      i,\n      true\n    );\n    this._closedColorBatches[\n      numberOfShadowModes + i\n    ] = new StaticGeometryColorBatch(\n      primitives,\n      PerInstanceColorAppearance,\n      undefined,\n      true,\n      i,\n      false\n    );\n\n    this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      MaterialAppearance,\n      undefined,\n      true,\n      i,\n      true\n    );\n    this._closedMaterialBatches[\n      numberOfShadowModes + i\n    ] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      MaterialAppearance,\n      undefined,\n      true,\n      i,\n      false\n    );\n\n    this._openColorBatches[i] = new StaticGeometryColorBatch(\n      primitives,\n      PerInstanceColorAppearance,\n      undefined,\n      false,\n      i,\n      true\n    );\n    this._openColorBatches[\n      numberOfShadowModes + i\n    ] = new StaticGeometryColorBatch(\n      primitives,\n      PerInstanceColorAppearance,\n      undefined,\n      false,\n      i,\n      false\n    );\n\n    this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      MaterialAppearance,\n      undefined,\n      false,\n      i,\n      true\n    );\n    this._openMaterialBatches[\n      numberOfShadowModes + i\n    ] = new StaticGeometryPerMaterialBatch(\n      primitives,\n      MaterialAppearance,\n      undefined,\n      false,\n      i,\n      false\n    );\n  }\n\n  var numberOfClassificationTypes =\n    ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n  var groundColorBatches = new Array(numberOfClassificationTypes);\n  var groundMaterialBatches = [];\n  if (supportsMaterialsforEntitiesOnTerrain) {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundMaterialBatches.push(\n        new StaticGroundGeometryPerMaterialBatch(\n          groundPrimitives,\n          i,\n          MaterialAppearance\n        )\n      );\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(\n        groundPrimitives,\n        i\n      );\n    }\n  } else {\n    for (i = 0; i < numberOfClassificationTypes; ++i) {\n      groundColorBatches[i] = new StaticGroundGeometryColorBatch(\n        groundPrimitives,\n        i\n      );\n    }\n  }\n\n  this._groundColorBatches = groundColorBatches;\n  this._groundMaterialBatches = groundMaterialBatches;\n\n  this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n  this._batches = this._outlineBatches.concat(\n    this._closedColorBatches,\n    this._closedMaterialBatches,\n    this._openColorBatches,\n    this._openMaterialBatches,\n    this._groundColorBatches,\n    this._groundMaterialBatches,\n    this._dynamicBatch\n  );\n\n  this._subscriptions = new AssociativeArray();\n  this._updaterSets = new AssociativeArray();\n\n  this._entityCollection = entityCollection;\n  entityCollection.collectionChanged.addEventListener(\n    GeometryVisualizer.prototype._onCollectionChanged,\n    this\n  );\n  this._onCollectionChanged(\n    entityCollection,\n    entityCollection.values,\n    emptyArray\n  );\n}\n\n/**\n * Updates all of the primitives created by this visualizer to match their\n * Entity counterpart at the given time.\n *\n * @param {JulianDate} time The time to update to.\n * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n * false if the visualizer is waiting for asynchronous primitives to be created.\n */\nGeometryVisualizer.prototype.update = function (time) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"time\", time);\n  //>>includeEnd('debug');\n\n  var addedObjects = this._addedObjects;\n  var added = addedObjects.values;\n  var removedObjects = this._removedObjects;\n  var removed = removedObjects.values;\n  var changedObjects = this._changedObjects;\n  var changed = changedObjects.values;\n\n  var i;\n  var entity;\n  var id;\n  var updaterSet;\n  var that = this;\n\n  for (i = changed.length - 1; i > -1; i--) {\n    entity = changed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id);\n\n    //If in a single update, an entity gets removed and a new instance\n    //re-added with the same id, the updater no longer tracks the\n    //correct entity, we need to both remove the old one and\n    //add the new one, which is done by pushing the entity\n    //onto the removed/added lists.\n    if (updaterSet.entity === entity) {\n      updaterSet.forEach(function (updater) {\n        that._removeUpdater(updater);\n        that._insertUpdaterIntoBatch(time, updater);\n      });\n    } else {\n      removed.push(entity);\n      added.push(entity);\n    }\n  }\n\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    updaterSet = this._updaterSets.get(id);\n    updaterSet.forEach(this._removeUpdater.bind(this));\n    updaterSet.destroy();\n    this._updaterSets.remove(id);\n    this._subscriptions.get(id)();\n    this._subscriptions.remove(id);\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    updaterSet = new GeometryUpdaterSet(entity, this._scene);\n    this._updaterSets.set(id, updaterSet);\n    updaterSet.forEach(function (updater) {\n      that._insertUpdaterIntoBatch(time, updater);\n    });\n    this._subscriptions.set(\n      id,\n      updaterSet.geometryChanged.addEventListener(\n        GeometryVisualizer._onGeometryChanged,\n        this\n      )\n    );\n  }\n\n  addedObjects.removeAll();\n  removedObjects.removeAll();\n  changedObjects.removeAll();\n\n  var isUpdated = true;\n  var batches = this._batches;\n  var length = batches.length;\n  for (i = 0; i < length; i++) {\n    isUpdated = batches[i].update(time) && isUpdated;\n  }\n\n  return isUpdated;\n};\n\nvar getBoundingSphereArrayScratch = [];\nvar getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n/**\n * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n * The bounding sphere is in the fixed frame of the scene's globe.\n *\n * @param {Entity} entity The entity whose bounding sphere to compute.\n * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n *                       BoundingSphereState.PENDING if the result is still being computed, or\n *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n * @private\n */\nGeometryVisualizer.prototype.getBoundingSphere = function (entity, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"entity\", entity);\n  Check.defined(\"result\", result);\n  //>>includeEnd('debug');\n\n  var boundingSpheres = getBoundingSphereArrayScratch;\n  var tmp = getBoundingSphereBoundingSphereScratch;\n\n  var count = 0;\n  var state = BoundingSphereState.DONE;\n  var batches = this._batches;\n  var batchesLength = batches.length;\n\n  var id = entity.id;\n  var updaters = this._updaterSets.get(id).updaters;\n\n  for (var j = 0; j < updaters.length; j++) {\n    var updater = updaters[j];\n    for (var i = 0; i < batchesLength; i++) {\n      state = batches[i].getBoundingSphere(updater, tmp);\n      if (state === BoundingSphereState.PENDING) {\n        return BoundingSphereState.PENDING;\n      } else if (state === BoundingSphereState.DONE) {\n        boundingSpheres[count] = BoundingSphere.clone(\n          tmp,\n          boundingSpheres[count]\n        );\n        count++;\n      }\n    }\n  }\n\n  if (count === 0) {\n    return BoundingSphereState.FAILED;\n  }\n\n  boundingSpheres.length = count;\n  BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n  return BoundingSphereState.DONE;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n */\nGeometryVisualizer.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes and destroys all primitives created by this instance.\n */\nGeometryVisualizer.prototype.destroy = function () {\n  this._entityCollection.collectionChanged.removeEventListener(\n    GeometryVisualizer.prototype._onCollectionChanged,\n    this\n  );\n  this._addedObjects.removeAll();\n  this._removedObjects.removeAll();\n\n  var i;\n  var batches = this._batches;\n  var length = batches.length;\n  for (i = 0; i < length; i++) {\n    batches[i].removeAllPrimitives();\n  }\n\n  var subscriptions = this._subscriptions.values;\n  length = subscriptions.length;\n  for (i = 0; i < length; i++) {\n    subscriptions[i]();\n  }\n  this._subscriptions.removeAll();\n\n  var updaterSets = this._updaterSets.values;\n  length = updaterSets.length;\n  for (i = 0; i < length; i++) {\n    updaterSets[i].destroy();\n  }\n  this._updaterSets.removeAll();\n  return destroyObject(this);\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._removeUpdater = function (updater) {\n  //We don't keep track of which batch an updater is in, so just remove it from all of them.\n  var batches = this._batches;\n  var length = batches.length;\n  for (var i = 0; i < length; i++) {\n    batches[i].remove(updater);\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._insertUpdaterIntoBatch = function (\n  time,\n  updater\n) {\n  if (updater.isDynamic) {\n    this._dynamicBatch.add(time, updater);\n    return;\n  }\n\n  var shadows;\n  if (updater.outlineEnabled || updater.fillEnabled) {\n    shadows = updater.shadowsProperty.getValue(time);\n  }\n\n  var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n  if (updater.outlineEnabled) {\n    if (defined(updater.terrainOffsetProperty)) {\n      this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n    } else {\n      this._outlineBatches[shadows].add(time, updater);\n    }\n  }\n\n  if (updater.fillEnabled) {\n    if (updater.onTerrain) {\n      var classificationType = updater.classificationTypeProperty.getValue(\n        time\n      );\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        this._groundColorBatches[classificationType].add(time, updater);\n      } else {\n        // If unsupported, updater will not be on terrain.\n        this._groundMaterialBatches[classificationType].add(time, updater);\n      }\n    } else if (updater.isClosed) {\n      if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n        if (defined(updater.terrainOffsetProperty)) {\n          this._closedColorBatches[numberOfShadowModes + shadows].add(\n            time,\n            updater\n          );\n        } else {\n          this._closedColorBatches[shadows].add(time, updater);\n        }\n      } else if (defined(updater.terrainOffsetProperty)) {\n        this._closedMaterialBatches[numberOfShadowModes + shadows].add(\n          time,\n          updater\n        );\n      } else {\n        this._closedMaterialBatches[shadows].add(time, updater);\n      }\n    } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n      if (defined(updater.terrainOffsetProperty)) {\n        this._openColorBatches[numberOfShadowModes + shadows].add(\n          time,\n          updater\n        );\n      } else {\n        this._openColorBatches[shadows].add(time, updater);\n      }\n    } else if (defined(updater.terrainOffsetProperty)) {\n      this._openMaterialBatches[numberOfShadowModes + shadows].add(\n        time,\n        updater\n      );\n    } else {\n      this._openMaterialBatches[shadows].add(time, updater);\n    }\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer._onGeometryChanged = function (updater) {\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n\n  var entity = updater.entity;\n  var id = entity.id;\n\n  if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n    changedObjects.set(id, entity);\n  }\n};\n\n/**\n * @private\n */\nGeometryVisualizer.prototype._onCollectionChanged = function (\n  entityCollection,\n  added,\n  removed\n) {\n  var addedObjects = this._addedObjects;\n  var removedObjects = this._removedObjects;\n  var changedObjects = this._changedObjects;\n\n  var i;\n  var id;\n  var entity;\n  for (i = removed.length - 1; i > -1; i--) {\n    entity = removed[i];\n    id = entity.id;\n    if (!addedObjects.remove(id)) {\n      removedObjects.set(id, entity);\n      changedObjects.remove(id);\n    }\n  }\n\n  for (i = added.length - 1; i > -1; i--) {\n    entity = added[i];\n    id = entity.id;\n    if (removedObjects.remove(id)) {\n      changedObjects.set(id, entity);\n    } else {\n      addedObjects.set(id, entity);\n    }\n  }\n};\nexport default GeometryVisualizer;\n"]},"metadata":{},"sourceType":"module"}