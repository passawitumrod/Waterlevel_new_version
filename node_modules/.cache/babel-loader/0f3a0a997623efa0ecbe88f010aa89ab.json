{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestType from \"../Core/RequestType.js\";\n/**\n * Provides functionality for ImageryProviders that have time dynamic imagery\n *\n * @alias TimeDynamicImagery\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Clock} options.clock A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.\n * @param {TimeIntervalCollection} options.times TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.\n * @param {Function} options.requestImageFunction A function that will request imagery tiles.\n * @param {Function} options.reloadFunction A function that will be called when all imagery tiles need to be reloaded.\n */\n\nfunction TimeDynamicImagery(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.times\", options.times);\n  Check.typeOf.func(\"options.requestImageFunction\", options.requestImageFunction);\n  Check.typeOf.func(\"options.reloadFunction\", options.reloadFunction); //>>includeEnd('debug');\n\n  this._tileCache = {};\n  this._tilesRequestedForInterval = [];\n  var clock = this._clock = options.clock;\n  this._times = options.times;\n  this._requestImageFunction = options.requestImageFunction;\n  this._reloadFunction = options.reloadFunction;\n  this._currentIntervalIndex = -1;\n  clock.onTick.addEventListener(this._clockOnTick, this);\n\n  this._clockOnTick(clock);\n}\n\nObject.defineProperties(TimeDynamicImagery.prototype, {\n  /**\n   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._clock !== value) {\n        this._clock = value;\n\n        this._clockOnTick(value);\n\n        this._reloadFunction();\n      }\n    }\n  },\n\n  /**\n   * Gets or sets a time interval collection.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeIntervalCollection}\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      if (this._times !== value) {\n        this._times = value;\n\n        this._clockOnTick(this._clock);\n\n        this._reloadFunction();\n      }\n    }\n  },\n\n  /**\n   * Gets the current interval.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeInterval}\n   */\n  currentInterval: {\n    get: function () {\n      return this._times.get(this._currentIntervalIndex);\n    }\n  }\n});\n/**\n * Gets the tile from the cache if its available.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<Image>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if the tile is not in the cache.\n */\n\nTimeDynamicImagery.prototype.getFromCache = function (x, y, level, request) {\n  var key = getKey(x, y, level);\n  var result;\n  var cache = this._tileCache[this._currentIntervalIndex];\n\n  if (defined(cache) && defined(cache[key])) {\n    var item = cache[key];\n    result = item.promise.otherwise(function (e) {\n      // Set the correct state in case it was cancelled\n      request.state = item.request.state;\n      throw e;\n    });\n    delete cache[key];\n  }\n\n  return result;\n};\n/**\n * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will\n * just add the tile to a list to preload when we approach the next interval.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n */\n\n\nTimeDynamicImagery.prototype.checkApproachingInterval = function (x, y, level, request) {\n  var key = getKey(x, y, level);\n  var tilesRequestedForInterval = this._tilesRequestedForInterval; // If we are approaching an interval, preload this tile in the next interval\n\n  var approachingInterval = getApproachingInterval(this);\n  var tile = {\n    key: key,\n    // Determines priority based on camera distance to the tile.\n    // Since the imagery regardless of time will be attached to the same tile we can just steal it.\n    priorityFunction: request.priorityFunction\n  };\n\n  if (!defined(approachingInterval) || !addToCache(this, tile, approachingInterval)) {\n    // Add to recent request list if we aren't approaching and interval or the request was throttled\n    tilesRequestedForInterval.push(tile);\n  } // Don't let the tile list get out of hand\n\n\n  if (tilesRequestedForInterval.length >= 512) {\n    tilesRequestedForInterval.splice(0, 256);\n  }\n};\n\nTimeDynamicImagery.prototype._clockOnTick = function (clock) {\n  var time = clock.currentTime;\n  var times = this._times;\n  var index = times.indexOf(time);\n  var currentIntervalIndex = this._currentIntervalIndex;\n\n  if (index !== currentIntervalIndex) {\n    // Cancel all outstanding requests and clear out caches not from current time interval\n    var currentCache = this._tileCache[currentIntervalIndex];\n\n    for (var t in currentCache) {\n      if (currentCache.hasOwnProperty(t)) {\n        currentCache[t].request.cancel();\n      }\n    }\n\n    delete this._tileCache[currentIntervalIndex];\n    this._tilesRequestedForInterval = [];\n    this._currentIntervalIndex = index;\n\n    this._reloadFunction();\n\n    return;\n  }\n\n  var approachingInterval = getApproachingInterval(this);\n\n  if (defined(approachingInterval)) {\n    // Start loading recent tiles from end of this._tilesRequestedForInterval\n    //  We keep preloading until we hit a throttling limit.\n    var tilesRequested = this._tilesRequestedForInterval;\n    var success = true;\n\n    while (success) {\n      if (tilesRequested.length === 0) {\n        break;\n      }\n\n      var tile = tilesRequested.pop();\n      success = addToCache(this, tile, approachingInterval);\n\n      if (!success) {\n        tilesRequested.push(tile);\n      }\n    }\n  }\n};\n\nfunction getKey(x, y, level) {\n  return x + \"-\" + y + \"-\" + level;\n}\n\nfunction getKeyElements(key) {\n  var s = key.split(\"-\");\n\n  if (s.length !== 3) {\n    return undefined;\n  }\n\n  return {\n    x: Number(s[0]),\n    y: Number(s[1]),\n    level: Number(s[2])\n  };\n}\n\nfunction getApproachingInterval(that) {\n  var times = that._times;\n\n  if (!defined(times)) {\n    return undefined;\n  }\n\n  var clock = that._clock;\n  var time = clock.currentTime;\n  var isAnimating = clock.canAnimate && clock.shouldAnimate;\n  var multiplier = clock.multiplier;\n\n  if (!isAnimating && multiplier !== 0) {\n    return undefined;\n  }\n\n  var seconds;\n  var index = times.indexOf(time);\n\n  if (index < 0) {\n    return undefined;\n  }\n\n  var interval = times.get(index);\n\n  if (multiplier > 0) {\n    // animating forward\n    seconds = JulianDate.secondsDifference(interval.stop, time);\n    ++index;\n  } else {\n    //backwards\n    seconds = JulianDate.secondsDifference(interval.start, time); // Will be negative\n\n    --index;\n  }\n\n  seconds /= multiplier; // Will always be positive\n  // Less than 5 wall time seconds\n\n  return index >= 0 && seconds <= 5.0 ? times.get(index) : undefined;\n}\n\nfunction addToCache(that, tile, interval) {\n  var index = that._times.indexOf(interval.start);\n\n  var tileCache = that._tileCache;\n  var intervalTileCache = tileCache[index];\n\n  if (!defined(intervalTileCache)) {\n    intervalTileCache = tileCache[index] = {};\n  }\n\n  var key = tile.key;\n\n  if (defined(intervalTileCache[key])) {\n    return true; // Already in the cache\n  }\n\n  var keyElements = getKeyElements(key);\n  var request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.IMAGERY,\n    priorityFunction: tile.priorityFunction\n  });\n\n  var promise = that._requestImageFunction(keyElements.x, keyElements.y, keyElements.level, request, interval);\n\n  if (!defined(promise)) {\n    return false;\n  }\n\n  intervalTileCache[key] = {\n    promise: promise,\n    request: request\n  };\n  return true;\n}\n\nexport default TimeDynamicImagery;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/TimeDynamicImagery.js"],"names":["Check","defaultValue","defined","DeveloperError","JulianDate","Request","RequestType","TimeDynamicImagery","options","EMPTY_OBJECT","typeOf","object","clock","times","func","requestImageFunction","reloadFunction","_tileCache","_tilesRequestedForInterval","_clock","_times","_requestImageFunction","_reloadFunction","_currentIntervalIndex","onTick","addEventListener","_clockOnTick","Object","defineProperties","prototype","get","set","value","currentInterval","getFromCache","x","y","level","request","key","getKey","result","cache","item","promise","otherwise","e","state","checkApproachingInterval","tilesRequestedForInterval","approachingInterval","getApproachingInterval","tile","priorityFunction","addToCache","push","length","splice","time","currentTime","index","indexOf","currentIntervalIndex","currentCache","t","hasOwnProperty","cancel","tilesRequested","success","pop","getKeyElements","s","split","undefined","Number","that","isAnimating","canAnimate","shouldAnimate","multiplier","seconds","interval","secondsDifference","stop","start","tileCache","intervalTileCache","keyElements","throttle","throttleByServer","type","IMAGERY"],"mappings":"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","sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport JulianDate from \"../Core/JulianDate.js\";\nimport Request from \"../Core/Request.js\";\nimport RequestType from \"../Core/RequestType.js\";\n\n/**\n * Provides functionality for ImageryProviders that have time dynamic imagery\n *\n * @alias TimeDynamicImagery\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Clock} options.clock A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.\n * @param {TimeIntervalCollection} options.times TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.\n * @param {Function} options.requestImageFunction A function that will request imagery tiles.\n * @param {Function} options.reloadFunction A function that will be called when all imagery tiles need to be reloaded.\n */\nfunction TimeDynamicImagery(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.clock\", options.clock);\n  Check.typeOf.object(\"options.times\", options.times);\n  Check.typeOf.func(\n    \"options.requestImageFunction\",\n    options.requestImageFunction\n  );\n  Check.typeOf.func(\"options.reloadFunction\", options.reloadFunction);\n  //>>includeEnd('debug');\n\n  this._tileCache = {};\n  this._tilesRequestedForInterval = [];\n\n  var clock = (this._clock = options.clock);\n  this._times = options.times;\n  this._requestImageFunction = options.requestImageFunction;\n  this._reloadFunction = options.reloadFunction;\n  this._currentIntervalIndex = -1;\n\n  clock.onTick.addEventListener(this._clockOnTick, this);\n  this._clockOnTick(clock);\n}\n\nObject.defineProperties(TimeDynamicImagery.prototype, {\n  /**\n   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {Clock}\n   */\n  clock: {\n    get: function () {\n      return this._clock;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._clock !== value) {\n        this._clock = value;\n        this._clockOnTick(value);\n        this._reloadFunction();\n      }\n    },\n  },\n  /**\n   * Gets or sets a time interval collection.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeIntervalCollection}\n   */\n  times: {\n    get: function () {\n      return this._times;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      if (this._times !== value) {\n        this._times = value;\n        this._clockOnTick(this._clock);\n        this._reloadFunction();\n      }\n    },\n  },\n  /**\n   * Gets the current interval.\n   * @memberof TimeDynamicImagery.prototype\n   * @type {TimeInterval}\n   */\n  currentInterval: {\n    get: function () {\n      return this._times.get(this._currentIntervalIndex);\n    },\n  },\n});\n\n/**\n * Gets the tile from the cache if its available.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n *\n * @returns {Promise.<Image>|undefined} A promise for the image that will resolve when the image is available, or\n *          undefined if the tile is not in the cache.\n */\nTimeDynamicImagery.prototype.getFromCache = function (x, y, level, request) {\n  var key = getKey(x, y, level);\n  var result;\n  var cache = this._tileCache[this._currentIntervalIndex];\n  if (defined(cache) && defined(cache[key])) {\n    var item = cache[key];\n    result = item.promise.otherwise(function (e) {\n      // Set the correct state in case it was cancelled\n      request.state = item.request.state;\n      throw e;\n    });\n    delete cache[key];\n  }\n\n  return result;\n};\n\n/**\n * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will\n * just add the tile to a list to preload when we approach the next interval.\n *\n * @param {Number} x The tile X coordinate.\n * @param {Number} y The tile Y coordinate.\n * @param {Number} level The tile level.\n * @param {Request} [request] The request object. Intended for internal use only.\n */\nTimeDynamicImagery.prototype.checkApproachingInterval = function (\n  x,\n  y,\n  level,\n  request\n) {\n  var key = getKey(x, y, level);\n  var tilesRequestedForInterval = this._tilesRequestedForInterval;\n\n  // If we are approaching an interval, preload this tile in the next interval\n  var approachingInterval = getApproachingInterval(this);\n  var tile = {\n    key: key,\n    // Determines priority based on camera distance to the tile.\n    // Since the imagery regardless of time will be attached to the same tile we can just steal it.\n    priorityFunction: request.priorityFunction,\n  };\n  if (\n    !defined(approachingInterval) ||\n    !addToCache(this, tile, approachingInterval)\n  ) {\n    // Add to recent request list if we aren't approaching and interval or the request was throttled\n    tilesRequestedForInterval.push(tile);\n  }\n\n  // Don't let the tile list get out of hand\n  if (tilesRequestedForInterval.length >= 512) {\n    tilesRequestedForInterval.splice(0, 256);\n  }\n};\n\nTimeDynamicImagery.prototype._clockOnTick = function (clock) {\n  var time = clock.currentTime;\n  var times = this._times;\n  var index = times.indexOf(time);\n  var currentIntervalIndex = this._currentIntervalIndex;\n\n  if (index !== currentIntervalIndex) {\n    // Cancel all outstanding requests and clear out caches not from current time interval\n    var currentCache = this._tileCache[currentIntervalIndex];\n    for (var t in currentCache) {\n      if (currentCache.hasOwnProperty(t)) {\n        currentCache[t].request.cancel();\n      }\n    }\n    delete this._tileCache[currentIntervalIndex];\n    this._tilesRequestedForInterval = [];\n\n    this._currentIntervalIndex = index;\n    this._reloadFunction();\n\n    return;\n  }\n\n  var approachingInterval = getApproachingInterval(this);\n  if (defined(approachingInterval)) {\n    // Start loading recent tiles from end of this._tilesRequestedForInterval\n    //  We keep preloading until we hit a throttling limit.\n    var tilesRequested = this._tilesRequestedForInterval;\n    var success = true;\n    while (success) {\n      if (tilesRequested.length === 0) {\n        break;\n      }\n\n      var tile = tilesRequested.pop();\n      success = addToCache(this, tile, approachingInterval);\n      if (!success) {\n        tilesRequested.push(tile);\n      }\n    }\n  }\n};\n\nfunction getKey(x, y, level) {\n  return x + \"-\" + y + \"-\" + level;\n}\n\nfunction getKeyElements(key) {\n  var s = key.split(\"-\");\n  if (s.length !== 3) {\n    return undefined;\n  }\n\n  return {\n    x: Number(s[0]),\n    y: Number(s[1]),\n    level: Number(s[2]),\n  };\n}\n\nfunction getApproachingInterval(that) {\n  var times = that._times;\n  if (!defined(times)) {\n    return undefined;\n  }\n  var clock = that._clock;\n  var time = clock.currentTime;\n  var isAnimating = clock.canAnimate && clock.shouldAnimate;\n  var multiplier = clock.multiplier;\n\n  if (!isAnimating && multiplier !== 0) {\n    return undefined;\n  }\n\n  var seconds;\n  var index = times.indexOf(time);\n  if (index < 0) {\n    return undefined;\n  }\n\n  var interval = times.get(index);\n  if (multiplier > 0) {\n    // animating forward\n    seconds = JulianDate.secondsDifference(interval.stop, time);\n    ++index;\n  } else {\n    //backwards\n    seconds = JulianDate.secondsDifference(interval.start, time); // Will be negative\n    --index;\n  }\n  seconds /= multiplier; // Will always be positive\n\n  // Less than 5 wall time seconds\n  return index >= 0 && seconds <= 5.0 ? times.get(index) : undefined;\n}\n\nfunction addToCache(that, tile, interval) {\n  var index = that._times.indexOf(interval.start);\n  var tileCache = that._tileCache;\n  var intervalTileCache = tileCache[index];\n  if (!defined(intervalTileCache)) {\n    intervalTileCache = tileCache[index] = {};\n  }\n\n  var key = tile.key;\n  if (defined(intervalTileCache[key])) {\n    return true; // Already in the cache\n  }\n\n  var keyElements = getKeyElements(key);\n  var request = new Request({\n    throttle: true,\n    throttleByServer: true,\n    type: RequestType.IMAGERY,\n    priorityFunction: tile.priorityFunction,\n  });\n  var promise = that._requestImageFunction(\n    keyElements.x,\n    keyElements.y,\n    keyElements.level,\n    request,\n    interval\n  );\n  if (!defined(promise)) {\n    return false;\n  }\n\n  intervalTileCache[key] = {\n    promise: promise,\n    request: request,\n  };\n\n  return true;\n}\nexport default TimeDynamicImagery;\n"]},"metadata":{},"sourceType":"module"}