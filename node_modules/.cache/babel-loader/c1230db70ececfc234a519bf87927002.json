{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport GeocodeType from \"./GeocodeType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n/**\n * Provides geocoding via a {@link https://pelias.io/|Pelias} server.\n * @alias PeliasGeocoderService\n * @constructor\n *\n * @param {Resource|String} url The endpoint to the Pelias server.\n *\n * @example\n * // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/\n * var viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({\n *     url: 'https://api.geocode.earth/v1/',\n *       queryParameters: {\n *         api_key: '<Your geocode.earth API key>'\n *     }\n *   }))\n * });\n */\n\nfunction PeliasGeocoderService(url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url); //>>includeEnd('debug');\n\n  this._url = Resource.createIfNeeded(url);\n\n  this._url.appendForwardSlash();\n}\n\nObject.defineProperties(PeliasGeocoderService.prototype, {\n  /**\n   * The Resource used to access the Pelias endpoint.\n   * @type {Resource}\n   * @memberof PeliasGeocoderService.prototype\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    }\n  }\n});\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService~Result[]>}\n */\n\nPeliasGeocoderService.prototype.geocode = function (query, type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query); //>>includeEnd('debug');\n\n  var resource = this._url.getDerivedResource({\n    url: type === GeocodeType.AUTOCOMPLETE ? \"autocomplete\" : \"search\",\n    queryParameters: {\n      text: query\n    }\n  });\n\n  return resource.fetchJson().then(function (results) {\n    return results.features.map(function (resultObject) {\n      var destination;\n      var bboxDegrees = resultObject.bbox;\n\n      if (defined(bboxDegrees)) {\n        destination = Rectangle.fromDegrees(bboxDegrees[0], bboxDegrees[1], bboxDegrees[2], bboxDegrees[3]);\n      } else {\n        var lon = resultObject.geometry.coordinates[0];\n        var lat = resultObject.geometry.coordinates[1];\n        destination = Cartesian3.fromDegrees(lon, lat);\n      }\n\n      return {\n        displayName: resultObject.properties.label,\n        destination: destination\n      };\n    });\n  });\n};\n\nexport default PeliasGeocoderService;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Core/PeliasGeocoderService.js"],"names":["Cartesian3","Check","defined","GeocodeType","Rectangle","Resource","PeliasGeocoderService","url","_url","createIfNeeded","appendForwardSlash","Object","defineProperties","prototype","get","geocode","query","type","typeOf","string","resource","getDerivedResource","AUTOCOMPLETE","queryParameters","text","fetchJson","then","results","features","map","resultObject","destination","bboxDegrees","bbox","fromDegrees","lon","geometry","coordinates","lat","displayName","properties","label"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,QAAP,MAAqB,eAArB;AAEA;;;;;;;;;;;;;;;;;;;AAkBA,SAASC,qBAAT,CAA+BC,GAA/B,EAAoC;AAClC;AACAN,EAAAA,KAAK,CAACC,OAAN,CAAc,KAAd,EAAqBK,GAArB,EAFkC,CAGlC;;AAEA,OAAKC,IAAL,GAAYH,QAAQ,CAACI,cAAT,CAAwBF,GAAxB,CAAZ;;AACA,OAAKC,IAAL,CAAUE,kBAAV;AACD;;AAEDC,MAAM,CAACC,gBAAP,CAAwBN,qBAAqB,CAACO,SAA9C,EAAyD;AACvD;;;;;;AAMAN,EAAAA,GAAG,EAAE;AACHO,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKN,IAAZ;AACD;AAHE;AAPkD,CAAzD;AAcA;;;;;;;;AAOAF,qBAAqB,CAACO,SAAtB,CAAgCE,OAAhC,GAA0C,UAAUC,KAAV,EAAiBC,IAAjB,EAAuB;AAC/D;AACAhB,EAAAA,KAAK,CAACiB,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6BH,KAA7B,EAF+D,CAG/D;;AAEA,MAAII,QAAQ,GAAG,KAAKZ,IAAL,CAAUa,kBAAV,CAA6B;AAC1Cd,IAAAA,GAAG,EAAEU,IAAI,KAAKd,WAAW,CAACmB,YAArB,GAAoC,cAApC,GAAqD,QADhB;AAE1CC,IAAAA,eAAe,EAAE;AACfC,MAAAA,IAAI,EAAER;AADS;AAFyB,GAA7B,CAAf;;AAOA,SAAOI,QAAQ,CAACK,SAAT,GAAqBC,IAArB,CAA0B,UAAUC,OAAV,EAAmB;AAClD,WAAOA,OAAO,CAACC,QAAR,CAAiBC,GAAjB,CAAqB,UAAUC,YAAV,EAAwB;AAClD,UAAIC,WAAJ;AACA,UAAIC,WAAW,GAAGF,YAAY,CAACG,IAA/B;;AAEA,UAAI/B,OAAO,CAAC8B,WAAD,CAAX,EAA0B;AACxBD,QAAAA,WAAW,GAAG3B,SAAS,CAAC8B,WAAV,CACZF,WAAW,CAAC,CAAD,CADC,EAEZA,WAAW,CAAC,CAAD,CAFC,EAGZA,WAAW,CAAC,CAAD,CAHC,EAIZA,WAAW,CAAC,CAAD,CAJC,CAAd;AAMD,OAPD,MAOO;AACL,YAAIG,GAAG,GAAGL,YAAY,CAACM,QAAb,CAAsBC,WAAtB,CAAkC,CAAlC,CAAV;AACA,YAAIC,GAAG,GAAGR,YAAY,CAACM,QAAb,CAAsBC,WAAtB,CAAkC,CAAlC,CAAV;AACAN,QAAAA,WAAW,GAAG/B,UAAU,CAACkC,WAAX,CAAuBC,GAAvB,EAA4BG,GAA5B,CAAd;AACD;;AAED,aAAO;AACLC,QAAAA,WAAW,EAAET,YAAY,CAACU,UAAb,CAAwBC,KADhC;AAELV,QAAAA,WAAW,EAAEA;AAFR,OAAP;AAID,KArBM,CAAP;AAsBD,GAvBM,CAAP;AAwBD,CApCD;;AAqCA,eAAezB,qBAAf","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defined from \"./defined.js\";\nimport GeocodeType from \"./GeocodeType.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Resource from \"./Resource.js\";\n\n/**\n * Provides geocoding via a {@link https://pelias.io/|Pelias} server.\n * @alias PeliasGeocoderService\n * @constructor\n *\n * @param {Resource|String} url The endpoint to the Pelias server.\n *\n * @example\n * // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/\n * var viewer = new Cesium.Viewer('cesiumContainer', {\n *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({\n *     url: 'https://api.geocode.earth/v1/',\n *       queryParameters: {\n *         api_key: '<Your geocode.earth API key>'\n *     }\n *   }))\n * });\n */\nfunction PeliasGeocoderService(url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  this._url = Resource.createIfNeeded(url);\n  this._url.appendForwardSlash();\n}\n\nObject.defineProperties(PeliasGeocoderService.prototype, {\n  /**\n   * The Resource used to access the Pelias endpoint.\n   * @type {Resource}\n   * @memberof PeliasGeocoderService.prototype\n   * @readonly\n   */\n  url: {\n    get: function () {\n      return this._url;\n    },\n  },\n});\n\n/**\n * @function\n *\n * @param {String} query The query to be sent to the geocoder service\n * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.\n * @returns {Promise<GeocoderService~Result[]>}\n */\nPeliasGeocoderService.prototype.geocode = function (query, type) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"query\", query);\n  //>>includeEnd('debug');\n\n  var resource = this._url.getDerivedResource({\n    url: type === GeocodeType.AUTOCOMPLETE ? \"autocomplete\" : \"search\",\n    queryParameters: {\n      text: query,\n    },\n  });\n\n  return resource.fetchJson().then(function (results) {\n    return results.features.map(function (resultObject) {\n      var destination;\n      var bboxDegrees = resultObject.bbox;\n\n      if (defined(bboxDegrees)) {\n        destination = Rectangle.fromDegrees(\n          bboxDegrees[0],\n          bboxDegrees[1],\n          bboxDegrees[2],\n          bboxDegrees[3]\n        );\n      } else {\n        var lon = resultObject.geometry.coordinates[0];\n        var lat = resultObject.geometry.coordinates[1];\n        destination = Cartesian3.fromDegrees(lon, lat);\n      }\n\n      return {\n        displayName: resultObject.properties.label,\n        destination: destination,\n      };\n    });\n  });\n};\nexport default PeliasGeocoderService;\n"]},"metadata":{},"sourceType":"module"}