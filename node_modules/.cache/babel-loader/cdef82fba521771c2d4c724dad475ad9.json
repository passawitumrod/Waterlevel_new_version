{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * Functions that do scene-dependent transforms between rendering-related coordinate systems.\n *\n * @exports SceneTransforms\n */\n\nvar SceneTransforms = {};\nvar actualPositionScratch = new Cartesian4(0, 0, 0, 1);\nvar positionCC = new Cartesian4();\nvar scratchViewport = new BoundingRectangle();\nvar scratchWindowCoord0 = new Cartesian2();\nvar scratchWindowCoord1 = new Cartesian2();\n/**\n * Transforms a position in WGS84 coordinates to window coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in WGS84 (world) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * var scene = widget.scene;\n * var ellipsoid = scene.globe.ellipsoid;\n * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\n\nSceneTransforms.wgs84ToWindowCoordinates = function (scene, position, result) {\n  return SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates(scene, position, Cartesian3.ZERO, result);\n};\n\nvar scratchCartesian4 = new Cartesian4();\nvar scratchEyeOffset = new Cartesian3();\n\nfunction worldToClip(position, eyeOffset, camera, result) {\n  var viewMatrix = camera.viewMatrix;\n  var positionEC = Matrix4.multiplyByVector(viewMatrix, Cartesian4.fromElements(position.x, position.y, position.z, 1, scratchCartesian4), scratchCartesian4);\n  var zEyeOffset = Cartesian3.multiplyComponents(eyeOffset, Cartesian3.normalize(positionEC, scratchEyeOffset), scratchEyeOffset);\n  positionEC.x += eyeOffset.x + zEyeOffset.x;\n  positionEC.y += eyeOffset.y + zEyeOffset.y;\n  positionEC.z += zEyeOffset.z;\n  return Matrix4.multiplyByVector(camera.frustum.projectionMatrix, positionEC, result);\n}\n\nvar scratchMaxCartographic = new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO);\nvar scratchProjectedCartesian = new Cartesian3();\nvar scratchCameraPosition = new Cartesian3();\n/**\n * @private\n */\n\nSceneTransforms.wgs84WithEyeOffsetToWindowCoordinates = function (scene, position, eyeOffset, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  } //>>includeEnd('debug');\n  // Transform for 3D, 2D, or Columbus view\n\n\n  var frameState = scene.frameState;\n  var actualPosition = SceneTransforms.computeActualWgs84Position(frameState, position, actualPositionScratch);\n\n  if (!defined(actualPosition)) {\n    return undefined;\n  } // Assuming viewport takes up the entire canvas...\n\n\n  var canvas = scene.canvas;\n  var viewport = scratchViewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = canvas.clientWidth;\n  viewport.height = canvas.clientHeight;\n  var camera = scene.camera;\n  var cameraCentered = false;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    var projection = scene.mapProjection;\n    var maxCartographic = scratchMaxCartographic;\n    var maxCoord = projection.project(maxCartographic, scratchProjectedCartesian);\n    var cameraPosition = Cartesian3.clone(camera.position, scratchCameraPosition);\n    var frustum = camera.frustum.clone();\n    var viewportTransformation = Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, new Matrix4());\n    var projectionMatrix = camera.frustum.projectionMatrix;\n    var x = camera.positionWC.y;\n    var eyePoint = Cartesian3.fromElements(CesiumMath.sign(x) * maxCoord.x - x, 0.0, -camera.positionWC.x);\n    var windowCoordinates = Transforms.pointToGLWindowCoordinates(projectionMatrix, viewportTransformation, eyePoint);\n\n    if (x === 0.0 || windowCoordinates.x <= 0.0 || windowCoordinates.x >= canvas.clientWidth) {\n      cameraCentered = true;\n    } else {\n      if (windowCoordinates.x > canvas.clientWidth * 0.5) {\n        viewport.width = windowCoordinates.x;\n        camera.frustum.right = maxCoord.x - x;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord0);\n        viewport.x += windowCoordinates.x;\n        camera.position.x = -camera.position.x;\n        var right = camera.frustum.right;\n        camera.frustum.right = -camera.frustum.left;\n        camera.frustum.left = -right;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord1);\n      } else {\n        viewport.x += windowCoordinates.x;\n        viewport.width -= windowCoordinates.x;\n        camera.frustum.left = -maxCoord.x - x;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord0);\n        viewport.x = viewport.x - viewport.width;\n        camera.position.x = -camera.position.x;\n        var left = camera.frustum.left;\n        camera.frustum.left = -camera.frustum.right;\n        camera.frustum.right = -left;\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, scratchWindowCoord1);\n      }\n\n      Cartesian3.clone(cameraPosition, camera.position);\n      camera.frustum = frustum.clone();\n      result = Cartesian2.clone(scratchWindowCoord0, result);\n\n      if (result.x < 0.0 || result.x > canvas.clientWidth) {\n        result.x = scratchWindowCoord1.x;\n      }\n    }\n  }\n\n  if (frameState.mode !== SceneMode.SCENE2D || cameraCentered) {\n    // View-projection matrix to transform from world coordinates to clip coordinates\n    positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n\n    if (positionCC.z < 0 && !(camera.frustum instanceof OrthographicFrustum) && !(camera.frustum instanceof OrthographicOffCenterFrustum)) {\n      return undefined;\n    }\n\n    result = SceneTransforms.clipToGLWindowCoordinates(viewport, positionCC, result);\n  }\n\n  result.y = canvas.clientHeight - result.y;\n  return result;\n};\n/**\n * Transforms a position in WGS84 coordinates to drawing buffer coordinates.  This may produce different\n * results from SceneTransforms.wgs84ToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in WGS84 (world) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * var scene = widget.scene;\n * var ellipsoid = scene.globe.ellipsoid;\n * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\n\n\nSceneTransforms.wgs84ToDrawingBufferCoordinates = function (scene, position, result) {\n  result = SceneTransforms.wgs84ToWindowCoordinates(scene, position, result);\n\n  if (!defined(result)) {\n    return undefined;\n  }\n\n  return SceneTransforms.transformWindowToDrawingBuffer(scene, result, result);\n};\n\nvar projectedPosition = new Cartesian3();\nvar positionInCartographic = new Cartographic();\n/**\n * @private\n */\n\nSceneTransforms.computeActualWgs84Position = function (frameState, position, result) {\n  var mode = frameState.mode;\n\n  if (mode === SceneMode.SCENE3D) {\n    return Cartesian3.clone(position, result);\n  }\n\n  var projection = frameState.mapProjection;\n  var cartographic = projection.ellipsoid.cartesianToCartographic(position, positionInCartographic);\n\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n\n  projection.project(cartographic, projectedPosition);\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Cartesian3.fromElements(projectedPosition.z, projectedPosition.x, projectedPosition.y, result);\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    return Cartesian3.fromElements(0.0, projectedPosition.x, projectedPosition.y, result);\n  } // mode === SceneMode.MORPHING\n\n\n  var morphTime = frameState.morphTime;\n  return Cartesian3.fromElements(CesiumMath.lerp(projectedPosition.z, position.x, morphTime), CesiumMath.lerp(projectedPosition.x, position.y, morphTime), CesiumMath.lerp(projectedPosition.y, position.z, morphTime), result);\n};\n\nvar positionNDC = new Cartesian3();\nvar positionWC = new Cartesian3();\nvar viewportTransform = new Matrix4();\n/**\n * @private\n */\n\nSceneTransforms.clipToGLWindowCoordinates = function (viewport, position, result) {\n  // Perspective divide to transform from clip coordinates to normalized device coordinates\n  Cartesian3.divideByScalar(position, position.w, positionNDC); // Viewport transform to transform from clip coordinates to window coordinates\n\n  Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, viewportTransform);\n  Matrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC);\n  return Cartesian2.fromCartesian3(positionWC, result);\n};\n/**\n * @private\n */\n\n\nSceneTransforms.transformWindowToDrawingBuffer = function (scene, windowPosition, result) {\n  var canvas = scene.canvas;\n  var xScale = scene.drawingBufferWidth / canvas.clientWidth;\n  var yScale = scene.drawingBufferHeight / canvas.clientHeight;\n  return Cartesian2.fromElements(windowPosition.x * xScale, windowPosition.y * yScale, result);\n};\n\nvar scratchNDC = new Cartesian4();\nvar scratchWorldCoords = new Cartesian4();\n/**\n * @private\n */\n\nSceneTransforms.drawingBufferToWgs84Coordinates = function (scene, drawingBufferPosition, depth, result) {\n  var context = scene.context;\n  var uniformState = context.uniformState;\n  var currentFrustum = uniformState.currentFrustum;\n  var near = currentFrustum.x;\n  var far = currentFrustum.y;\n\n  if (scene.frameState.useLogDepth) {\n    // transforming logarithmic depth of form\n    // log2(z + 1) / log2( far + 1);\n    // to perspective form\n    // (far - far * near / z) / (far - near)\n    var log2Depth = depth * uniformState.log2FarDepthFromNearPlusOne;\n    var depthFromNear = Math.pow(2.0, log2Depth) - 1.0;\n    depth = far * (1.0 - near / (depthFromNear + near)) / (far - near);\n  }\n\n  var viewport = scene.view.passState.viewport;\n  var ndc = Cartesian4.clone(Cartesian4.UNIT_W, scratchNDC);\n  ndc.x = (drawingBufferPosition.x - viewport.x) / viewport.width * 2.0 - 1.0;\n  ndc.y = (drawingBufferPosition.y - viewport.y) / viewport.height * 2.0 - 1.0;\n  ndc.z = depth * 2.0 - 1.0;\n  ndc.w = 1.0;\n  var worldCoords;\n  var frustum = scene.camera.frustum;\n\n  if (!defined(frustum.fovy)) {\n    if (defined(frustum._offCenterFrustum)) {\n      frustum = frustum._offCenterFrustum;\n    }\n\n    worldCoords = scratchWorldCoords;\n    worldCoords.x = (ndc.x * (frustum.right - frustum.left) + frustum.left + frustum.right) * 0.5;\n    worldCoords.y = (ndc.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) * 0.5;\n    worldCoords.z = (ndc.z * (near - far) - near - far) * 0.5;\n    worldCoords.w = 1.0;\n    worldCoords = Matrix4.multiplyByVector(uniformState.inverseView, worldCoords, worldCoords);\n  } else {\n    worldCoords = Matrix4.multiplyByVector(uniformState.inverseViewProjection, ndc, scratchWorldCoords); // Reverse perspective divide\n\n    var w = 1.0 / worldCoords.w;\n    Cartesian3.multiplyByScalar(worldCoords, w, worldCoords);\n  }\n\n  return Cartesian3.fromCartesian4(worldCoords, result);\n};\n\nexport default SceneTransforms;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterLevelReact/node_modules/cesium/Source/Scene/SceneTransforms.js"],"names":["BoundingRectangle","Cartesian2","Cartesian3","Cartesian4","Cartographic","defined","DeveloperError","CesiumMath","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","Transforms","SceneMode","SceneTransforms","actualPositionScratch","positionCC","scratchViewport","scratchWindowCoord0","scratchWindowCoord1","wgs84ToWindowCoordinates","scene","position","result","wgs84WithEyeOffsetToWindowCoordinates","ZERO","scratchCartesian4","scratchEyeOffset","worldToClip","eyeOffset","camera","viewMatrix","positionEC","multiplyByVector","fromElements","x","y","z","zEyeOffset","multiplyComponents","normalize","frustum","projectionMatrix","scratchMaxCartographic","Math","PI","PI_OVER_TWO","scratchProjectedCartesian","scratchCameraPosition","frameState","actualPosition","computeActualWgs84Position","undefined","canvas","viewport","width","clientWidth","height","clientHeight","cameraCentered","mode","SCENE2D","projection","mapProjection","maxCartographic","maxCoord","project","cameraPosition","clone","viewportTransformation","computeViewportTransformation","positionWC","eyePoint","sign","windowCoordinates","pointToGLWindowCoordinates","right","clipToGLWindowCoordinates","left","wgs84ToDrawingBufferCoordinates","transformWindowToDrawingBuffer","projectedPosition","positionInCartographic","SCENE3D","cartographic","ellipsoid","cartesianToCartographic","COLUMBUS_VIEW","morphTime","lerp","positionNDC","viewportTransform","divideByScalar","w","multiplyByPoint","fromCartesian3","windowPosition","xScale","drawingBufferWidth","yScale","drawingBufferHeight","scratchNDC","scratchWorldCoords","drawingBufferToWgs84Coordinates","drawingBufferPosition","depth","context","uniformState","currentFrustum","near","far","useLogDepth","log2Depth","log2FarDepthFromNearPlusOne","depthFromNear","pow","view","passState","ndc","UNIT_W","worldCoords","fovy","_offCenterFrustum","top","bottom","inverseView","inverseViewProjection","multiplyByScalar","fromCartesian4"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * Functions that do scene-dependent transforms between rendering-related coordinate systems.\n *\n * @exports SceneTransforms\n */\nvar SceneTransforms = {};\n\nvar actualPositionScratch = new Cartesian4(0, 0, 0, 1);\nvar positionCC = new Cartesian4();\nvar scratchViewport = new BoundingRectangle();\n\nvar scratchWindowCoord0 = new Cartesian2();\nvar scratchWindowCoord1 = new Cartesian2();\n\n/**\n * Transforms a position in WGS84 coordinates to window coordinates.  This is commonly used to place an\n * HTML element at the same screen position as an object in the scene.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in WGS84 (world) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * var scene = widget.scene;\n * var ellipsoid = scene.globe.ellipsoid;\n * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.wgs84ToWindowCoordinates = function (scene, position, result) {\n  return SceneTransforms.wgs84WithEyeOffsetToWindowCoordinates(\n    scene,\n    position,\n    Cartesian3.ZERO,\n    result\n  );\n};\n\nvar scratchCartesian4 = new Cartesian4();\nvar scratchEyeOffset = new Cartesian3();\n\nfunction worldToClip(position, eyeOffset, camera, result) {\n  var viewMatrix = camera.viewMatrix;\n\n  var positionEC = Matrix4.multiplyByVector(\n    viewMatrix,\n    Cartesian4.fromElements(\n      position.x,\n      position.y,\n      position.z,\n      1,\n      scratchCartesian4\n    ),\n    scratchCartesian4\n  );\n\n  var zEyeOffset = Cartesian3.multiplyComponents(\n    eyeOffset,\n    Cartesian3.normalize(positionEC, scratchEyeOffset),\n    scratchEyeOffset\n  );\n  positionEC.x += eyeOffset.x + zEyeOffset.x;\n  positionEC.y += eyeOffset.y + zEyeOffset.y;\n  positionEC.z += zEyeOffset.z;\n\n  return Matrix4.multiplyByVector(\n    camera.frustum.projectionMatrix,\n    positionEC,\n    result\n  );\n}\n\nvar scratchMaxCartographic = new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO);\nvar scratchProjectedCartesian = new Cartesian3();\nvar scratchCameraPosition = new Cartesian3();\n\n/**\n * @private\n */\nSceneTransforms.wgs84WithEyeOffsetToWindowCoordinates = function (\n  scene,\n  position,\n  eyeOffset,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  if (!defined(position)) {\n    throw new DeveloperError(\"position is required.\");\n  }\n  //>>includeEnd('debug');\n\n  // Transform for 3D, 2D, or Columbus view\n  var frameState = scene.frameState;\n  var actualPosition = SceneTransforms.computeActualWgs84Position(\n    frameState,\n    position,\n    actualPositionScratch\n  );\n\n  if (!defined(actualPosition)) {\n    return undefined;\n  }\n\n  // Assuming viewport takes up the entire canvas...\n  var canvas = scene.canvas;\n  var viewport = scratchViewport;\n  viewport.x = 0;\n  viewport.y = 0;\n  viewport.width = canvas.clientWidth;\n  viewport.height = canvas.clientHeight;\n\n  var camera = scene.camera;\n  var cameraCentered = false;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    var projection = scene.mapProjection;\n    var maxCartographic = scratchMaxCartographic;\n    var maxCoord = projection.project(\n      maxCartographic,\n      scratchProjectedCartesian\n    );\n\n    var cameraPosition = Cartesian3.clone(\n      camera.position,\n      scratchCameraPosition\n    );\n    var frustum = camera.frustum.clone();\n\n    var viewportTransformation = Matrix4.computeViewportTransformation(\n      viewport,\n      0.0,\n      1.0,\n      new Matrix4()\n    );\n    var projectionMatrix = camera.frustum.projectionMatrix;\n\n    var x = camera.positionWC.y;\n    var eyePoint = Cartesian3.fromElements(\n      CesiumMath.sign(x) * maxCoord.x - x,\n      0.0,\n      -camera.positionWC.x\n    );\n    var windowCoordinates = Transforms.pointToGLWindowCoordinates(\n      projectionMatrix,\n      viewportTransformation,\n      eyePoint\n    );\n\n    if (\n      x === 0.0 ||\n      windowCoordinates.x <= 0.0 ||\n      windowCoordinates.x >= canvas.clientWidth\n    ) {\n      cameraCentered = true;\n    } else {\n      if (windowCoordinates.x > canvas.clientWidth * 0.5) {\n        viewport.width = windowCoordinates.x;\n\n        camera.frustum.right = maxCoord.x - x;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord0\n        );\n\n        viewport.x += windowCoordinates.x;\n\n        camera.position.x = -camera.position.x;\n\n        var right = camera.frustum.right;\n        camera.frustum.right = -camera.frustum.left;\n        camera.frustum.left = -right;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord1\n        );\n      } else {\n        viewport.x += windowCoordinates.x;\n        viewport.width -= windowCoordinates.x;\n\n        camera.frustum.left = -maxCoord.x - x;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord0\n        );\n\n        viewport.x = viewport.x - viewport.width;\n\n        camera.position.x = -camera.position.x;\n\n        var left = camera.frustum.left;\n        camera.frustum.left = -camera.frustum.right;\n        camera.frustum.right = -left;\n\n        positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n        SceneTransforms.clipToGLWindowCoordinates(\n          viewport,\n          positionCC,\n          scratchWindowCoord1\n        );\n      }\n\n      Cartesian3.clone(cameraPosition, camera.position);\n      camera.frustum = frustum.clone();\n\n      result = Cartesian2.clone(scratchWindowCoord0, result);\n      if (result.x < 0.0 || result.x > canvas.clientWidth) {\n        result.x = scratchWindowCoord1.x;\n      }\n    }\n  }\n\n  if (frameState.mode !== SceneMode.SCENE2D || cameraCentered) {\n    // View-projection matrix to transform from world coordinates to clip coordinates\n    positionCC = worldToClip(actualPosition, eyeOffset, camera, positionCC);\n    if (\n      positionCC.z < 0 &&\n      !(camera.frustum instanceof OrthographicFrustum) &&\n      !(camera.frustum instanceof OrthographicOffCenterFrustum)\n    ) {\n      return undefined;\n    }\n\n    result = SceneTransforms.clipToGLWindowCoordinates(\n      viewport,\n      positionCC,\n      result\n    );\n  }\n\n  result.y = canvas.clientHeight - result.y;\n  return result;\n};\n\n/**\n * Transforms a position in WGS84 coordinates to drawing buffer coordinates.  This may produce different\n * results from SceneTransforms.wgs84ToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.\n *\n * @param {Scene} scene The scene.\n * @param {Cartesian3} position The position in WGS84 (world) coordinates.\n * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.\n *\n * @example\n * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.\n * var scene = widget.scene;\n * var ellipsoid = scene.globe.ellipsoid;\n * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);\n * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);\n * handler.setInputAction(function(movement) {\n *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));\n * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);\n */\nSceneTransforms.wgs84ToDrawingBufferCoordinates = function (\n  scene,\n  position,\n  result\n) {\n  result = SceneTransforms.wgs84ToWindowCoordinates(scene, position, result);\n  if (!defined(result)) {\n    return undefined;\n  }\n\n  return SceneTransforms.transformWindowToDrawingBuffer(scene, result, result);\n};\n\nvar projectedPosition = new Cartesian3();\nvar positionInCartographic = new Cartographic();\n\n/**\n * @private\n */\nSceneTransforms.computeActualWgs84Position = function (\n  frameState,\n  position,\n  result\n) {\n  var mode = frameState.mode;\n\n  if (mode === SceneMode.SCENE3D) {\n    return Cartesian3.clone(position, result);\n  }\n\n  var projection = frameState.mapProjection;\n  var cartographic = projection.ellipsoid.cartesianToCartographic(\n    position,\n    positionInCartographic\n  );\n  if (!defined(cartographic)) {\n    return undefined;\n  }\n\n  projection.project(cartographic, projectedPosition);\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Cartesian3.fromElements(\n      projectedPosition.z,\n      projectedPosition.x,\n      projectedPosition.y,\n      result\n    );\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    return Cartesian3.fromElements(\n      0.0,\n      projectedPosition.x,\n      projectedPosition.y,\n      result\n    );\n  }\n\n  // mode === SceneMode.MORPHING\n  var morphTime = frameState.morphTime;\n  return Cartesian3.fromElements(\n    CesiumMath.lerp(projectedPosition.z, position.x, morphTime),\n    CesiumMath.lerp(projectedPosition.x, position.y, morphTime),\n    CesiumMath.lerp(projectedPosition.y, position.z, morphTime),\n    result\n  );\n};\n\nvar positionNDC = new Cartesian3();\nvar positionWC = new Cartesian3();\nvar viewportTransform = new Matrix4();\n\n/**\n * @private\n */\nSceneTransforms.clipToGLWindowCoordinates = function (\n  viewport,\n  position,\n  result\n) {\n  // Perspective divide to transform from clip coordinates to normalized device coordinates\n  Cartesian3.divideByScalar(position, position.w, positionNDC);\n\n  // Viewport transform to transform from clip coordinates to window coordinates\n  Matrix4.computeViewportTransformation(viewport, 0.0, 1.0, viewportTransform);\n  Matrix4.multiplyByPoint(viewportTransform, positionNDC, positionWC);\n\n  return Cartesian2.fromCartesian3(positionWC, result);\n};\n\n/**\n * @private\n */\nSceneTransforms.transformWindowToDrawingBuffer = function (\n  scene,\n  windowPosition,\n  result\n) {\n  var canvas = scene.canvas;\n  var xScale = scene.drawingBufferWidth / canvas.clientWidth;\n  var yScale = scene.drawingBufferHeight / canvas.clientHeight;\n  return Cartesian2.fromElements(\n    windowPosition.x * xScale,\n    windowPosition.y * yScale,\n    result\n  );\n};\n\nvar scratchNDC = new Cartesian4();\nvar scratchWorldCoords = new Cartesian4();\n\n/**\n * @private\n */\nSceneTransforms.drawingBufferToWgs84Coordinates = function (\n  scene,\n  drawingBufferPosition,\n  depth,\n  result\n) {\n  var context = scene.context;\n  var uniformState = context.uniformState;\n\n  var currentFrustum = uniformState.currentFrustum;\n  var near = currentFrustum.x;\n  var far = currentFrustum.y;\n\n  if (scene.frameState.useLogDepth) {\n    // transforming logarithmic depth of form\n    // log2(z + 1) / log2( far + 1);\n    // to perspective form\n    // (far - far * near / z) / (far - near)\n    var log2Depth = depth * uniformState.log2FarDepthFromNearPlusOne;\n    var depthFromNear = Math.pow(2.0, log2Depth) - 1.0;\n    depth = (far * (1.0 - near / (depthFromNear + near))) / (far - near);\n  }\n\n  var viewport = scene.view.passState.viewport;\n  var ndc = Cartesian4.clone(Cartesian4.UNIT_W, scratchNDC);\n  ndc.x = ((drawingBufferPosition.x - viewport.x) / viewport.width) * 2.0 - 1.0;\n  ndc.y =\n    ((drawingBufferPosition.y - viewport.y) / viewport.height) * 2.0 - 1.0;\n  ndc.z = depth * 2.0 - 1.0;\n  ndc.w = 1.0;\n\n  var worldCoords;\n  var frustum = scene.camera.frustum;\n  if (!defined(frustum.fovy)) {\n    if (defined(frustum._offCenterFrustum)) {\n      frustum = frustum._offCenterFrustum;\n    }\n    worldCoords = scratchWorldCoords;\n    worldCoords.x =\n      (ndc.x * (frustum.right - frustum.left) + frustum.left + frustum.right) *\n      0.5;\n    worldCoords.y =\n      (ndc.y * (frustum.top - frustum.bottom) + frustum.bottom + frustum.top) *\n      0.5;\n    worldCoords.z = (ndc.z * (near - far) - near - far) * 0.5;\n    worldCoords.w = 1.0;\n\n    worldCoords = Matrix4.multiplyByVector(\n      uniformState.inverseView,\n      worldCoords,\n      worldCoords\n    );\n  } else {\n    worldCoords = Matrix4.multiplyByVector(\n      uniformState.inverseViewProjection,\n      ndc,\n      scratchWorldCoords\n    );\n\n    // Reverse perspective divide\n    var w = 1.0 / worldCoords.w;\n    Cartesian3.multiplyByScalar(worldCoords, w, worldCoords);\n  }\n  return Cartesian3.fromCartesian4(worldCoords, result);\n};\nexport default SceneTransforms;\n"]},"metadata":{},"sourceType":"module"}