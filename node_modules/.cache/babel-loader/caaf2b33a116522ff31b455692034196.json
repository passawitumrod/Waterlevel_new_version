{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport ImageryState from \"./ImageryState.js\";\n/**\n * The assocation between a terrain tile and an imagery tile.\n *\n * @alias TileImagery\n * @private\n *\n * @param {Imagery} imagery The imagery tile.\n * @param {Cartesian4} textureCoordinateRectangle The texture rectangle of the tile that is covered\n *        by the imagery, where X=west, Y=south, Z=east, W=north.\n * @param {Boolean} useWebMercatorT true to use the Web Mercator texture coordinates for this imagery tile.\n */\n\nfunction TileImagery(imagery, textureCoordinateRectangle, useWebMercatorT) {\n  this.readyImagery = undefined;\n  this.loadingImagery = imagery;\n  this.textureCoordinateRectangle = textureCoordinateRectangle;\n  this.textureTranslationAndScale = undefined;\n  this.useWebMercatorT = useWebMercatorT;\n}\n/**\n * Frees the resources held by this instance.\n */\n\n\nTileImagery.prototype.freeResources = function () {\n  if (defined(this.readyImagery)) {\n    this.readyImagery.releaseReference();\n  }\n\n  if (defined(this.loadingImagery)) {\n    this.loadingImagery.releaseReference();\n  }\n};\n/**\n * Processes the load state machine for this instance.\n *\n * @param {Tile} tile The tile to which this instance belongs.\n * @param {FrameState} frameState The frameState.\n * @param {Boolean} skipLoading True to skip loading, e.g. new requests, creating textures. This function will\n *                  still synchronously process imagery that's already mostly ready to go, e.g. use textures\n *                  already loaded on ancestor tiles.\n * @returns {Boolean} True if this instance is done loading; otherwise, false.\n */\n\n\nTileImagery.prototype.processStateMachine = function (tile, frameState, skipLoading) {\n  var loadingImagery = this.loadingImagery;\n  var imageryLayer = loadingImagery.imageryLayer;\n  loadingImagery.processStateMachine(frameState, !this.useWebMercatorT, skipLoading);\n\n  if (loadingImagery.state === ImageryState.READY) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n\n    this.readyImagery = this.loadingImagery;\n    this.loadingImagery = undefined;\n    this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, this);\n    return true; // done loading\n  } // Find some ancestor imagery we can use while this imagery is still loading.\n\n\n  var ancestor = loadingImagery.parent;\n  var closestAncestorThatNeedsLoading;\n\n  while (defined(ancestor) && (ancestor.state !== ImageryState.READY || !this.useWebMercatorT && !defined(ancestor.texture))) {\n    if (ancestor.state !== ImageryState.FAILED && ancestor.state !== ImageryState.INVALID) {\n      // ancestor is still loading\n      closestAncestorThatNeedsLoading = closestAncestorThatNeedsLoading || ancestor;\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  if (this.readyImagery !== ancestor) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n\n    this.readyImagery = ancestor;\n\n    if (defined(ancestor)) {\n      ancestor.addReference();\n      this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, this);\n    }\n  }\n\n  if (loadingImagery.state === ImageryState.FAILED || loadingImagery.state === ImageryState.INVALID) {\n    // The imagery tile is failed or invalid, so we'd like to use an ancestor instead.\n    if (defined(closestAncestorThatNeedsLoading)) {\n      // Push the ancestor's load process along a bit.  This is necessary because some ancestor imagery\n      // tiles may not be attached directly to a terrain tile.  Such tiles will never load if\n      // we don't do it here.\n      closestAncestorThatNeedsLoading.processStateMachine(frameState, !this.useWebMercatorT, skipLoading);\n      return false; // not done loading\n    } // This imagery tile is failed or invalid, and we have the \"best available\" substitute.\n\n\n    return true; // done loading\n  }\n\n  return false; // not done loading\n};\n\nexport default TileImagery;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Scene/TileImagery.js"],"names":["defined","ImageryState","TileImagery","imagery","textureCoordinateRectangle","useWebMercatorT","readyImagery","undefined","loadingImagery","textureTranslationAndScale","prototype","freeResources","releaseReference","processStateMachine","tile","frameState","skipLoading","imageryLayer","state","READY","_calculateTextureTranslationAndScale","ancestor","parent","closestAncestorThatNeedsLoading","texture","FAILED","INVALID","addReference"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,oBAApB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AAEA;;;;;;;;;;;;AAWA,SAASC,WAAT,CAAqBC,OAArB,EAA8BC,0BAA9B,EAA0DC,eAA1D,EAA2E;AACzE,OAAKC,YAAL,GAAoBC,SAApB;AACA,OAAKC,cAAL,GAAsBL,OAAtB;AACA,OAAKC,0BAAL,GAAkCA,0BAAlC;AACA,OAAKK,0BAAL,GAAkCF,SAAlC;AACA,OAAKF,eAAL,GAAuBA,eAAvB;AACD;AAED;;;;;AAGAH,WAAW,CAACQ,SAAZ,CAAsBC,aAAtB,GAAsC,YAAY;AAChD,MAAIX,OAAO,CAAC,KAAKM,YAAN,CAAX,EAAgC;AAC9B,SAAKA,YAAL,CAAkBM,gBAAlB;AACD;;AAED,MAAIZ,OAAO,CAAC,KAAKQ,cAAN,CAAX,EAAkC;AAChC,SAAKA,cAAL,CAAoBI,gBAApB;AACD;AACF,CARD;AAUA;;;;;;;;;;;;AAUAV,WAAW,CAACQ,SAAZ,CAAsBG,mBAAtB,GAA4C,UAC1CC,IAD0C,EAE1CC,UAF0C,EAG1CC,WAH0C,EAI1C;AACA,MAAIR,cAAc,GAAG,KAAKA,cAA1B;AACA,MAAIS,YAAY,GAAGT,cAAc,CAACS,YAAlC;AAEAT,EAAAA,cAAc,CAACK,mBAAf,CACEE,UADF,EAEE,CAAC,KAAKV,eAFR,EAGEW,WAHF;;AAMA,MAAIR,cAAc,CAACU,KAAf,KAAyBjB,YAAY,CAACkB,KAA1C,EAAiD;AAC/C,QAAInB,OAAO,CAAC,KAAKM,YAAN,CAAX,EAAgC;AAC9B,WAAKA,YAAL,CAAkBM,gBAAlB;AACD;;AACD,SAAKN,YAAL,GAAoB,KAAKE,cAAzB;AACA,SAAKA,cAAL,GAAsBD,SAAtB;AACA,SAAKE,0BAAL,GAAkCQ,YAAY,CAACG,oCAAb,CAChCN,IADgC,EAEhC,IAFgC,CAAlC;AAIA,WAAO,IAAP,CAV+C,CAUlC;AACd,GArBD,CAuBA;;;AACA,MAAIO,QAAQ,GAAGb,cAAc,CAACc,MAA9B;AACA,MAAIC,+BAAJ;;AACA,SACEvB,OAAO,CAACqB,QAAD,CAAP,KACCA,QAAQ,CAACH,KAAT,KAAmBjB,YAAY,CAACkB,KAAhC,IACE,CAAC,KAAKd,eAAN,IAAyB,CAACL,OAAO,CAACqB,QAAQ,CAACG,OAAV,CAFpC,CADF,EAIE;AACA,QACEH,QAAQ,CAACH,KAAT,KAAmBjB,YAAY,CAACwB,MAAhC,IACAJ,QAAQ,CAACH,KAAT,KAAmBjB,YAAY,CAACyB,OAFlC,EAGE;AACA;AACAH,MAAAA,+BAA+B,GAC7BA,+BAA+B,IAAIF,QADrC;AAED;;AACDA,IAAAA,QAAQ,GAAGA,QAAQ,CAACC,MAApB;AACD;;AAED,MAAI,KAAKhB,YAAL,KAAsBe,QAA1B,EAAoC;AAClC,QAAIrB,OAAO,CAAC,KAAKM,YAAN,CAAX,EAAgC;AAC9B,WAAKA,YAAL,CAAkBM,gBAAlB;AACD;;AAED,SAAKN,YAAL,GAAoBe,QAApB;;AAEA,QAAIrB,OAAO,CAACqB,QAAD,CAAX,EAAuB;AACrBA,MAAAA,QAAQ,CAACM,YAAT;AACA,WAAKlB,0BAAL,GAAkCQ,YAAY,CAACG,oCAAb,CAChCN,IADgC,EAEhC,IAFgC,CAAlC;AAID;AACF;;AAED,MACEN,cAAc,CAACU,KAAf,KAAyBjB,YAAY,CAACwB,MAAtC,IACAjB,cAAc,CAACU,KAAf,KAAyBjB,YAAY,CAACyB,OAFxC,EAGE;AACA;AACA,QAAI1B,OAAO,CAACuB,+BAAD,CAAX,EAA8C;AAC5C;AACA;AACA;AACAA,MAAAA,+BAA+B,CAACV,mBAAhC,CACEE,UADF,EAEE,CAAC,KAAKV,eAFR,EAGEW,WAHF;AAKA,aAAO,KAAP,CAT4C,CAS9B;AACf,KAZD,CAaA;;;AACA,WAAO,IAAP,CAdA,CAca;AACd;;AAED,SAAO,KAAP,CA9EA,CA8Ec;AACf,CAnFD;;AAoFA,eAAed,WAAf","sourcesContent":["import defined from \"../Core/defined.js\";\nimport ImageryState from \"./ImageryState.js\";\n\n/**\n * The assocation between a terrain tile and an imagery tile.\n *\n * @alias TileImagery\n * @private\n *\n * @param {Imagery} imagery The imagery tile.\n * @param {Cartesian4} textureCoordinateRectangle The texture rectangle of the tile that is covered\n *        by the imagery, where X=west, Y=south, Z=east, W=north.\n * @param {Boolean} useWebMercatorT true to use the Web Mercator texture coordinates for this imagery tile.\n */\nfunction TileImagery(imagery, textureCoordinateRectangle, useWebMercatorT) {\n  this.readyImagery = undefined;\n  this.loadingImagery = imagery;\n  this.textureCoordinateRectangle = textureCoordinateRectangle;\n  this.textureTranslationAndScale = undefined;\n  this.useWebMercatorT = useWebMercatorT;\n}\n\n/**\n * Frees the resources held by this instance.\n */\nTileImagery.prototype.freeResources = function () {\n  if (defined(this.readyImagery)) {\n    this.readyImagery.releaseReference();\n  }\n\n  if (defined(this.loadingImagery)) {\n    this.loadingImagery.releaseReference();\n  }\n};\n\n/**\n * Processes the load state machine for this instance.\n *\n * @param {Tile} tile The tile to which this instance belongs.\n * @param {FrameState} frameState The frameState.\n * @param {Boolean} skipLoading True to skip loading, e.g. new requests, creating textures. This function will\n *                  still synchronously process imagery that's already mostly ready to go, e.g. use textures\n *                  already loaded on ancestor tiles.\n * @returns {Boolean} True if this instance is done loading; otherwise, false.\n */\nTileImagery.prototype.processStateMachine = function (\n  tile,\n  frameState,\n  skipLoading\n) {\n  var loadingImagery = this.loadingImagery;\n  var imageryLayer = loadingImagery.imageryLayer;\n\n  loadingImagery.processStateMachine(\n    frameState,\n    !this.useWebMercatorT,\n    skipLoading\n  );\n\n  if (loadingImagery.state === ImageryState.READY) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n    this.readyImagery = this.loadingImagery;\n    this.loadingImagery = undefined;\n    this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(\n      tile,\n      this\n    );\n    return true; // done loading\n  }\n\n  // Find some ancestor imagery we can use while this imagery is still loading.\n  var ancestor = loadingImagery.parent;\n  var closestAncestorThatNeedsLoading;\n  while (\n    defined(ancestor) &&\n    (ancestor.state !== ImageryState.READY ||\n      (!this.useWebMercatorT && !defined(ancestor.texture)))\n  ) {\n    if (\n      ancestor.state !== ImageryState.FAILED &&\n      ancestor.state !== ImageryState.INVALID\n    ) {\n      // ancestor is still loading\n      closestAncestorThatNeedsLoading =\n        closestAncestorThatNeedsLoading || ancestor;\n    }\n    ancestor = ancestor.parent;\n  }\n\n  if (this.readyImagery !== ancestor) {\n    if (defined(this.readyImagery)) {\n      this.readyImagery.releaseReference();\n    }\n\n    this.readyImagery = ancestor;\n\n    if (defined(ancestor)) {\n      ancestor.addReference();\n      this.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(\n        tile,\n        this\n      );\n    }\n  }\n\n  if (\n    loadingImagery.state === ImageryState.FAILED ||\n    loadingImagery.state === ImageryState.INVALID\n  ) {\n    // The imagery tile is failed or invalid, so we'd like to use an ancestor instead.\n    if (defined(closestAncestorThatNeedsLoading)) {\n      // Push the ancestor's load process along a bit.  This is necessary because some ancestor imagery\n      // tiles may not be attached directly to a terrain tile.  Such tiles will never load if\n      // we don't do it here.\n      closestAncestorThatNeedsLoading.processStateMachine(\n        frameState,\n        !this.useWebMercatorT,\n        skipLoading\n      );\n      return false; // not done loading\n    }\n    // This imagery tile is failed or invalid, and we have the \"best available\" substitute.\n    return true; // done loading\n  }\n\n  return false; // not done loading\n};\nexport default TileImagery;\n"]},"metadata":{},"sourceType":"module"}