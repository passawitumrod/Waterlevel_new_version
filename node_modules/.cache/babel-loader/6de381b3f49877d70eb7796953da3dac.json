{"ast":null,"code":"import Uri from \"../ThirdParty/Uri.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Event from \"./Event.js\";\nimport Heap from \"./Heap.js\";\nimport isBlobUri from \"./isBlobUri.js\";\nimport isDataUri from \"./isDataUri.js\";\nimport RequestState from \"./RequestState.js\";\n\nfunction sortRequests(a, b) {\n  return a.priority - b.priority;\n}\n\nvar statistics = {\n  numberOfAttemptedRequests: 0,\n  numberOfActiveRequests: 0,\n  numberOfCancelledRequests: 0,\n  numberOfCancelledActiveRequests: 0,\n  numberOfFailedRequests: 0,\n  numberOfActiveRequestsEver: 0,\n  lastNumberOfActiveRequests: 0\n};\nvar priorityHeapLength = 20;\nvar requestHeap = new Heap({\n  comparator: sortRequests\n});\nrequestHeap.maximumLength = priorityHeapLength;\nrequestHeap.reserve(priorityHeapLength);\nvar activeRequests = [];\nvar numberOfActiveRequestsByServer = {};\nvar pageUri = typeof document !== \"undefined\" ? new Uri(document.location.href) : new Uri();\nvar requestCompletedEvent = new Event();\n/**\n * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability\n * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,\n * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the\n * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.\n *\n * @exports RequestScheduler\n *\n */\n\nfunction RequestScheduler() {}\n/**\n * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n * @type {Number}\n * @default 50\n */\n\n\nRequestScheduler.maximumRequests = 50;\n/**\n * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically\n * listed in {@link requestsByServer} do not observe this limit.\n * @type {Number}\n * @default 6\n */\n\nRequestScheduler.maximumRequestsPerServer = 6;\n/**\n * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>\n *\n * @example\n * RequestScheduler.requestsByServer = {\n *   'api.cesium.com:443': 18,\n *   'assets.cesium.com:443': 18\n * };\n */\n\nRequestScheduler.requestsByServer = {\n  \"api.cesium.com:443\": 18,\n  \"assets.cesium.com:443\": 18\n};\n/**\n * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.\n * @type {Boolean}\n * @default true\n */\n\nRequestScheduler.throttleRequests = true;\n/**\n * When true, log statistics to the console every frame\n * @type {Boolean}\n * @default false\n * @private\n */\n\nRequestScheduler.debugShowStatistics = false;\n/**\n * An event that's raised when a request is completed.  Event handlers are passed\n * the error object if the request fails.\n *\n * @type {Event}\n * @default Event()\n * @private\n */\n\nRequestScheduler.requestCompletedEvent = requestCompletedEvent;\nObject.defineProperties(RequestScheduler, {\n  /**\n   * Returns the statistics used by the request scheduler.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type Object\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return statistics;\n    }\n  },\n\n  /**\n   * The maximum size of the priority heap. This limits the number of requests that are sorted by priority. Only applies to requests that are not yet active.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {Number}\n   * @default 20\n   * @private\n   */\n  priorityHeapLength: {\n    get: function () {\n      return priorityHeapLength;\n    },\n    set: function (value) {\n      // If the new length shrinks the heap, need to cancel some of the requests.\n      // Since this value is not intended to be tweaked regularly it is fine to just cancel the high priority requests.\n      if (value < priorityHeapLength) {\n        while (requestHeap.length > value) {\n          var request = requestHeap.pop();\n          cancelRequest(request);\n        }\n      }\n\n      priorityHeapLength = value;\n      requestHeap.maximumLength = value;\n      requestHeap.reserve(value);\n    }\n  }\n});\n\nfunction updatePriority(request) {\n  if (defined(request.priorityFunction)) {\n    request.priority = request.priorityFunction();\n  }\n}\n\nfunction serverHasOpenSlots(serverKey) {\n  var maxRequests = defaultValue(RequestScheduler.requestsByServer[serverKey], RequestScheduler.maximumRequestsPerServer);\n  return numberOfActiveRequestsByServer[serverKey] < maxRequests;\n}\n\nfunction issueRequest(request) {\n  if (request.state === RequestState.UNISSUED) {\n    request.state = RequestState.ISSUED;\n    request.deferred = when.defer();\n  }\n\n  return request.deferred.promise;\n}\n\nfunction getRequestReceivedFunction(request) {\n  return function (results) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    request.deferred.resolve(results);\n  };\n}\n\nfunction getRequestFailedFunction(request) {\n  return function (error) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n\n    ++statistics.numberOfFailedRequests;\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent(error);\n    request.state = RequestState.FAILED;\n    request.deferred.reject(error);\n  };\n}\n\nfunction startRequest(request) {\n  var promise = issueRequest(request);\n  request.state = RequestState.ACTIVE;\n  activeRequests.push(request);\n  ++statistics.numberOfActiveRequests;\n  ++statistics.numberOfActiveRequestsEver;\n  ++numberOfActiveRequestsByServer[request.serverKey];\n  request.requestFunction().then(getRequestReceivedFunction(request)).otherwise(getRequestFailedFunction(request));\n  return promise;\n}\n\nfunction cancelRequest(request) {\n  var active = request.state === RequestState.ACTIVE;\n  request.state = RequestState.CANCELLED;\n  ++statistics.numberOfCancelledRequests;\n  request.deferred.reject();\n\n  if (active) {\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    ++statistics.numberOfCancelledActiveRequests;\n  }\n\n  if (defined(request.cancelFunction)) {\n    request.cancelFunction();\n  }\n}\n/**\n * Sort requests by priority and start requests.\n * @private\n */\n\n\nRequestScheduler.update = function () {\n  var i;\n  var request; // Loop over all active requests. Cancelled, failed, or received requests are removed from the array to make room for new requests.\n\n  var removeCount = 0;\n  var activeLength = activeRequests.length;\n\n  for (i = 0; i < activeLength; ++i) {\n    request = activeRequests[i];\n\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n    }\n\n    if (request.state !== RequestState.ACTIVE) {\n      // Request is no longer active, remove from array\n      ++removeCount;\n      continue;\n    }\n\n    if (removeCount > 0) {\n      // Shift back to fill in vacated slots from completed requests\n      activeRequests[i - removeCount] = request;\n    }\n  }\n\n  activeRequests.length -= removeCount; // Update priority of issued requests and resort the heap\n\n  var issuedRequests = requestHeap.internalArray;\n  var issuedLength = requestHeap.length;\n\n  for (i = 0; i < issuedLength; ++i) {\n    updatePriority(issuedRequests[i]);\n  }\n\n  requestHeap.resort(); // Get the number of open slots and fill with the highest priority requests.\n  // Un-throttled requests are automatically added to activeRequests, so activeRequests.length may exceed maximumRequests\n\n  var openSlots = Math.max(RequestScheduler.maximumRequests - activeRequests.length, 0);\n  var filledSlots = 0;\n\n  while (filledSlots < openSlots && requestHeap.length > 0) {\n    // Loop until all open slots are filled or the heap becomes empty\n    request = requestHeap.pop();\n\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n      continue;\n    }\n\n    if (request.throttleByServer && !serverHasOpenSlots(request.serverKey)) {\n      // Open slots are available, but the request is throttled by its server. Cancel and try again later.\n      cancelRequest(request);\n      continue;\n    }\n\n    startRequest(request);\n    ++filledSlots;\n  }\n\n  updateStatistics();\n};\n/**\n * Get the server key from a given url.\n *\n * @param {String} url The url.\n * @returns {String} The server key.\n * @private\n */\n\n\nRequestScheduler.getServerKey = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"url\", url); //>>includeEnd('debug');\n\n  var uri = new Uri(url).resolve(pageUri);\n  uri.normalize();\n  var serverKey = uri.authority;\n\n  if (!/:/.test(serverKey)) {\n    // If the authority does not contain a port number, add port 443 for https or port 80 for http\n    serverKey = serverKey + \":\" + (uri.scheme === \"https\" ? \"443\" : \"80\");\n  }\n\n  var length = numberOfActiveRequestsByServer[serverKey];\n\n  if (!defined(length)) {\n    numberOfActiveRequestsByServer[serverKey] = 0;\n  }\n\n  return serverKey;\n};\n/**\n * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be\n * queued and sorted by priority before being sent.\n *\n * @param {Request} request The request object.\n *\n * @returns {Promise|undefined} A Promise for the requested data, or undefined if this request does not have high enough priority to be issued.\n *\n * @private\n */\n\n\nRequestScheduler.request = function (request) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"request\", request);\n  Check.typeOf.string(\"request.url\", request.url);\n  Check.typeOf.func(\"request.requestFunction\", request.requestFunction); //>>includeEnd('debug');\n\n  if (isDataUri(request.url) || isBlobUri(request.url)) {\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    return request.requestFunction();\n  }\n\n  ++statistics.numberOfAttemptedRequests;\n\n  if (!defined(request.serverKey)) {\n    request.serverKey = RequestScheduler.getServerKey(request.url);\n  }\n\n  if (RequestScheduler.throttleRequests && request.throttleByServer && !serverHasOpenSlots(request.serverKey)) {\n    // Server is saturated. Try again later.\n    return undefined;\n  }\n\n  if (!RequestScheduler.throttleRequests || !request.throttle) {\n    return startRequest(request);\n  }\n\n  if (activeRequests.length >= RequestScheduler.maximumRequests) {\n    // Active requests are saturated. Try again later.\n    return undefined;\n  } // Insert into the priority heap and see if a request was bumped off. If this request is the lowest\n  // priority it will be returned.\n\n\n  updatePriority(request);\n  var removedRequest = requestHeap.insert(request);\n\n  if (defined(removedRequest)) {\n    if (removedRequest === request) {\n      // Request does not have high enough priority to be issued\n      return undefined;\n    } // A previously issued request has been bumped off the priority heap, so cancel it\n\n\n    cancelRequest(removedRequest);\n  }\n\n  return issueRequest(request);\n};\n\nfunction updateStatistics() {\n  if (!RequestScheduler.debugShowStatistics) {\n    return;\n  }\n\n  if (statistics.numberOfActiveRequests === 0 && statistics.lastNumberOfActiveRequests > 0) {\n    if (statistics.numberOfAttemptedRequests > 0) {\n      console.log(\"Number of attempted requests: \" + statistics.numberOfAttemptedRequests);\n      statistics.numberOfAttemptedRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledRequests > 0) {\n      console.log(\"Number of cancelled requests: \" + statistics.numberOfCancelledRequests);\n      statistics.numberOfCancelledRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledActiveRequests > 0) {\n      console.log(\"Number of cancelled active requests: \" + statistics.numberOfCancelledActiveRequests);\n      statistics.numberOfCancelledActiveRequests = 0;\n    }\n\n    if (statistics.numberOfFailedRequests > 0) {\n      console.log(\"Number of failed requests: \" + statistics.numberOfFailedRequests);\n      statistics.numberOfFailedRequests = 0;\n    }\n  }\n\n  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;\n}\n/**\n * For testing only. Clears any requests that may not have completed from previous tests.\n *\n * @private\n */\n\n\nRequestScheduler.clearForSpecs = function () {\n  while (requestHeap.length > 0) {\n    var request = requestHeap.pop();\n    cancelRequest(request);\n  }\n\n  var length = activeRequests.length;\n\n  for (var i = 0; i < length; ++i) {\n    cancelRequest(activeRequests[i]);\n  }\n\n  activeRequests.length = 0;\n  numberOfActiveRequestsByServer = {}; // Clear stats\n\n  statistics.numberOfAttemptedRequests = 0;\n  statistics.numberOfActiveRequests = 0;\n  statistics.numberOfCancelledRequests = 0;\n  statistics.numberOfCancelledActiveRequests = 0;\n  statistics.numberOfFailedRequests = 0;\n  statistics.numberOfActiveRequestsEver = 0;\n  statistics.lastNumberOfActiveRequests = 0;\n};\n/**\n * For testing only.\n *\n * @private\n */\n\n\nRequestScheduler.numberOfActiveRequestsByServer = function (serverKey) {\n  return numberOfActiveRequestsByServer[serverKey];\n};\n/**\n * For testing only.\n *\n * @private\n */\n\n\nRequestScheduler.requestHeap = requestHeap;\nexport default RequestScheduler;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/RequestScheduler.js"],"names":["Uri","when","Check","defaultValue","defined","Event","Heap","isBlobUri","isDataUri","RequestState","sortRequests","a","b","priority","statistics","numberOfAttemptedRequests","numberOfActiveRequests","numberOfCancelledRequests","numberOfCancelledActiveRequests","numberOfFailedRequests","numberOfActiveRequestsEver","lastNumberOfActiveRequests","priorityHeapLength","requestHeap","comparator","maximumLength","reserve","activeRequests","numberOfActiveRequestsByServer","pageUri","document","location","href","requestCompletedEvent","RequestScheduler","maximumRequests","maximumRequestsPerServer","requestsByServer","throttleRequests","debugShowStatistics","Object","defineProperties","get","set","value","length","request","pop","cancelRequest","updatePriority","priorityFunction","serverHasOpenSlots","serverKey","maxRequests","issueRequest","state","UNISSUED","ISSUED","deferred","defer","promise","getRequestReceivedFunction","results","CANCELLED","raiseEvent","RECEIVED","resolve","getRequestFailedFunction","error","FAILED","reject","startRequest","ACTIVE","push","requestFunction","then","otherwise","active","cancelFunction","update","i","removeCount","activeLength","cancelled","issuedRequests","internalArray","issuedLength","resort","openSlots","Math","max","filledSlots","throttleByServer","updateStatistics","getServerKey","url","typeOf","string","uri","normalize","authority","test","scheme","object","func","undefined","throttle","removedRequest","insert","console","log","clearForSpecs"],"mappings":"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","sourcesContent":["import Uri from \"../ThirdParty/Uri.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Event from \"./Event.js\";\nimport Heap from \"./Heap.js\";\nimport isBlobUri from \"./isBlobUri.js\";\nimport isDataUri from \"./isDataUri.js\";\nimport RequestState from \"./RequestState.js\";\n\nfunction sortRequests(a, b) {\n  return a.priority - b.priority;\n}\n\nvar statistics = {\n  numberOfAttemptedRequests: 0,\n  numberOfActiveRequests: 0,\n  numberOfCancelledRequests: 0,\n  numberOfCancelledActiveRequests: 0,\n  numberOfFailedRequests: 0,\n  numberOfActiveRequestsEver: 0,\n  lastNumberOfActiveRequests: 0,\n};\n\nvar priorityHeapLength = 20;\nvar requestHeap = new Heap({\n  comparator: sortRequests,\n});\nrequestHeap.maximumLength = priorityHeapLength;\nrequestHeap.reserve(priorityHeapLength);\n\nvar activeRequests = [];\nvar numberOfActiveRequestsByServer = {};\n\nvar pageUri =\n  typeof document !== \"undefined\" ? new Uri(document.location.href) : new Uri();\n\nvar requestCompletedEvent = new Event();\n\n/**\n * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability\n * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,\n * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the\n * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.\n *\n * @exports RequestScheduler\n *\n */\nfunction RequestScheduler() {}\n\n/**\n * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n * @type {Number}\n * @default 50\n */\nRequestScheduler.maximumRequests = 50;\n\n/**\n * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically\n * listed in {@link requestsByServer} do not observe this limit.\n * @type {Number}\n * @default 6\n */\nRequestScheduler.maximumRequestsPerServer = 6;\n\n/**\n * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>\n *\n * @example\n * RequestScheduler.requestsByServer = {\n *   'api.cesium.com:443': 18,\n *   'assets.cesium.com:443': 18\n * };\n */\nRequestScheduler.requestsByServer = {\n  \"api.cesium.com:443\": 18,\n  \"assets.cesium.com:443\": 18,\n};\n\n/**\n * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.\n * @type {Boolean}\n * @default true\n */\nRequestScheduler.throttleRequests = true;\n\n/**\n * When true, log statistics to the console every frame\n * @type {Boolean}\n * @default false\n * @private\n */\nRequestScheduler.debugShowStatistics = false;\n\n/**\n * An event that's raised when a request is completed.  Event handlers are passed\n * the error object if the request fails.\n *\n * @type {Event}\n * @default Event()\n * @private\n */\nRequestScheduler.requestCompletedEvent = requestCompletedEvent;\n\nObject.defineProperties(RequestScheduler, {\n  /**\n   * Returns the statistics used by the request scheduler.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type Object\n   * @readonly\n   * @private\n   */\n  statistics: {\n    get: function () {\n      return statistics;\n    },\n  },\n\n  /**\n   * The maximum size of the priority heap. This limits the number of requests that are sorted by priority. Only applies to requests that are not yet active.\n   *\n   * @memberof RequestScheduler\n   *\n   * @type {Number}\n   * @default 20\n   * @private\n   */\n  priorityHeapLength: {\n    get: function () {\n      return priorityHeapLength;\n    },\n    set: function (value) {\n      // If the new length shrinks the heap, need to cancel some of the requests.\n      // Since this value is not intended to be tweaked regularly it is fine to just cancel the high priority requests.\n      if (value < priorityHeapLength) {\n        while (requestHeap.length > value) {\n          var request = requestHeap.pop();\n          cancelRequest(request);\n        }\n      }\n      priorityHeapLength = value;\n      requestHeap.maximumLength = value;\n      requestHeap.reserve(value);\n    },\n  },\n});\n\nfunction updatePriority(request) {\n  if (defined(request.priorityFunction)) {\n    request.priority = request.priorityFunction();\n  }\n}\n\nfunction serverHasOpenSlots(serverKey) {\n  var maxRequests = defaultValue(\n    RequestScheduler.requestsByServer[serverKey],\n    RequestScheduler.maximumRequestsPerServer\n  );\n  return numberOfActiveRequestsByServer[serverKey] < maxRequests;\n}\n\nfunction issueRequest(request) {\n  if (request.state === RequestState.UNISSUED) {\n    request.state = RequestState.ISSUED;\n    request.deferred = when.defer();\n  }\n  return request.deferred.promise;\n}\n\nfunction getRequestReceivedFunction(request) {\n  return function (results) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    request.deferred.resolve(results);\n  };\n}\n\nfunction getRequestFailedFunction(request) {\n  return function (error) {\n    if (request.state === RequestState.CANCELLED) {\n      // If the data request comes back but the request is cancelled, ignore it.\n      return;\n    }\n    ++statistics.numberOfFailedRequests;\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    requestCompletedEvent.raiseEvent(error);\n    request.state = RequestState.FAILED;\n    request.deferred.reject(error);\n  };\n}\n\nfunction startRequest(request) {\n  var promise = issueRequest(request);\n  request.state = RequestState.ACTIVE;\n  activeRequests.push(request);\n  ++statistics.numberOfActiveRequests;\n  ++statistics.numberOfActiveRequestsEver;\n  ++numberOfActiveRequestsByServer[request.serverKey];\n  request\n    .requestFunction()\n    .then(getRequestReceivedFunction(request))\n    .otherwise(getRequestFailedFunction(request));\n  return promise;\n}\n\nfunction cancelRequest(request) {\n  var active = request.state === RequestState.ACTIVE;\n  request.state = RequestState.CANCELLED;\n  ++statistics.numberOfCancelledRequests;\n  request.deferred.reject();\n\n  if (active) {\n    --statistics.numberOfActiveRequests;\n    --numberOfActiveRequestsByServer[request.serverKey];\n    ++statistics.numberOfCancelledActiveRequests;\n  }\n\n  if (defined(request.cancelFunction)) {\n    request.cancelFunction();\n  }\n}\n\n/**\n * Sort requests by priority and start requests.\n * @private\n */\nRequestScheduler.update = function () {\n  var i;\n  var request;\n\n  // Loop over all active requests. Cancelled, failed, or received requests are removed from the array to make room for new requests.\n  var removeCount = 0;\n  var activeLength = activeRequests.length;\n  for (i = 0; i < activeLength; ++i) {\n    request = activeRequests[i];\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n    }\n    if (request.state !== RequestState.ACTIVE) {\n      // Request is no longer active, remove from array\n      ++removeCount;\n      continue;\n    }\n    if (removeCount > 0) {\n      // Shift back to fill in vacated slots from completed requests\n      activeRequests[i - removeCount] = request;\n    }\n  }\n  activeRequests.length -= removeCount;\n\n  // Update priority of issued requests and resort the heap\n  var issuedRequests = requestHeap.internalArray;\n  var issuedLength = requestHeap.length;\n  for (i = 0; i < issuedLength; ++i) {\n    updatePriority(issuedRequests[i]);\n  }\n  requestHeap.resort();\n\n  // Get the number of open slots and fill with the highest priority requests.\n  // Un-throttled requests are automatically added to activeRequests, so activeRequests.length may exceed maximumRequests\n  var openSlots = Math.max(\n    RequestScheduler.maximumRequests - activeRequests.length,\n    0\n  );\n  var filledSlots = 0;\n  while (filledSlots < openSlots && requestHeap.length > 0) {\n    // Loop until all open slots are filled or the heap becomes empty\n    request = requestHeap.pop();\n    if (request.cancelled) {\n      // Request was explicitly cancelled\n      cancelRequest(request);\n      continue;\n    }\n\n    if (request.throttleByServer && !serverHasOpenSlots(request.serverKey)) {\n      // Open slots are available, but the request is throttled by its server. Cancel and try again later.\n      cancelRequest(request);\n      continue;\n    }\n\n    startRequest(request);\n    ++filledSlots;\n  }\n\n  updateStatistics();\n};\n\n/**\n * Get the server key from a given url.\n *\n * @param {String} url The url.\n * @returns {String} The server key.\n * @private\n */\nRequestScheduler.getServerKey = function (url) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"url\", url);\n  //>>includeEnd('debug');\n\n  var uri = new Uri(url).resolve(pageUri);\n  uri.normalize();\n  var serverKey = uri.authority;\n  if (!/:/.test(serverKey)) {\n    // If the authority does not contain a port number, add port 443 for https or port 80 for http\n    serverKey = serverKey + \":\" + (uri.scheme === \"https\" ? \"443\" : \"80\");\n  }\n\n  var length = numberOfActiveRequestsByServer[serverKey];\n  if (!defined(length)) {\n    numberOfActiveRequestsByServer[serverKey] = 0;\n  }\n\n  return serverKey;\n};\n\n/**\n * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be\n * queued and sorted by priority before being sent.\n *\n * @param {Request} request The request object.\n *\n * @returns {Promise|undefined} A Promise for the requested data, or undefined if this request does not have high enough priority to be issued.\n *\n * @private\n */\nRequestScheduler.request = function (request) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"request\", request);\n  Check.typeOf.string(\"request.url\", request.url);\n  Check.typeOf.func(\"request.requestFunction\", request.requestFunction);\n  //>>includeEnd('debug');\n\n  if (isDataUri(request.url) || isBlobUri(request.url)) {\n    requestCompletedEvent.raiseEvent();\n    request.state = RequestState.RECEIVED;\n    return request.requestFunction();\n  }\n\n  ++statistics.numberOfAttemptedRequests;\n\n  if (!defined(request.serverKey)) {\n    request.serverKey = RequestScheduler.getServerKey(request.url);\n  }\n\n  if (\n    RequestScheduler.throttleRequests &&\n    request.throttleByServer &&\n    !serverHasOpenSlots(request.serverKey)\n  ) {\n    // Server is saturated. Try again later.\n    return undefined;\n  }\n\n  if (!RequestScheduler.throttleRequests || !request.throttle) {\n    return startRequest(request);\n  }\n\n  if (activeRequests.length >= RequestScheduler.maximumRequests) {\n    // Active requests are saturated. Try again later.\n    return undefined;\n  }\n\n  // Insert into the priority heap and see if a request was bumped off. If this request is the lowest\n  // priority it will be returned.\n  updatePriority(request);\n  var removedRequest = requestHeap.insert(request);\n\n  if (defined(removedRequest)) {\n    if (removedRequest === request) {\n      // Request does not have high enough priority to be issued\n      return undefined;\n    }\n    // A previously issued request has been bumped off the priority heap, so cancel it\n    cancelRequest(removedRequest);\n  }\n\n  return issueRequest(request);\n};\n\nfunction updateStatistics() {\n  if (!RequestScheduler.debugShowStatistics) {\n    return;\n  }\n\n  if (\n    statistics.numberOfActiveRequests === 0 &&\n    statistics.lastNumberOfActiveRequests > 0\n  ) {\n    if (statistics.numberOfAttemptedRequests > 0) {\n      console.log(\n        \"Number of attempted requests: \" + statistics.numberOfAttemptedRequests\n      );\n      statistics.numberOfAttemptedRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledRequests > 0) {\n      console.log(\n        \"Number of cancelled requests: \" + statistics.numberOfCancelledRequests\n      );\n      statistics.numberOfCancelledRequests = 0;\n    }\n\n    if (statistics.numberOfCancelledActiveRequests > 0) {\n      console.log(\n        \"Number of cancelled active requests: \" +\n          statistics.numberOfCancelledActiveRequests\n      );\n      statistics.numberOfCancelledActiveRequests = 0;\n    }\n\n    if (statistics.numberOfFailedRequests > 0) {\n      console.log(\n        \"Number of failed requests: \" + statistics.numberOfFailedRequests\n      );\n      statistics.numberOfFailedRequests = 0;\n    }\n  }\n\n  statistics.lastNumberOfActiveRequests = statistics.numberOfActiveRequests;\n}\n\n/**\n * For testing only. Clears any requests that may not have completed from previous tests.\n *\n * @private\n */\nRequestScheduler.clearForSpecs = function () {\n  while (requestHeap.length > 0) {\n    var request = requestHeap.pop();\n    cancelRequest(request);\n  }\n  var length = activeRequests.length;\n  for (var i = 0; i < length; ++i) {\n    cancelRequest(activeRequests[i]);\n  }\n  activeRequests.length = 0;\n  numberOfActiveRequestsByServer = {};\n\n  // Clear stats\n  statistics.numberOfAttemptedRequests = 0;\n  statistics.numberOfActiveRequests = 0;\n  statistics.numberOfCancelledRequests = 0;\n  statistics.numberOfCancelledActiveRequests = 0;\n  statistics.numberOfFailedRequests = 0;\n  statistics.numberOfActiveRequestsEver = 0;\n  statistics.lastNumberOfActiveRequests = 0;\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.numberOfActiveRequestsByServer = function (serverKey) {\n  return numberOfActiveRequestsByServer[serverKey];\n};\n\n/**\n * For testing only.\n *\n * @private\n */\nRequestScheduler.requestHeap = requestHeap;\nexport default RequestScheduler;\n"]},"metadata":{},"sourceType":"module"}