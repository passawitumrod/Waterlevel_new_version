{"ast":null,"code":"import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Transforms from \"./Transforms.js\";\n/**\n * A geometry representation with attributes forming vertices and optional index data\n * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\n * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\n * be created from many heterogeneous - in many cases - geometries for performance.\n * <p>\n * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\n * </p>\n *\n * @alias Geometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\n * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\n * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\n * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\n *\n * @see PolygonGeometry\n * @see RectangleGeometry\n * @see EllipseGeometry\n * @see CircleGeometry\n * @see WallGeometry\n * @see SimplePolylineGeometry\n * @see BoxGeometry\n * @see EllipsoidGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n *\n * @example\n * // Create geometry with a position attribute and indexed lines.\n * var positions = new Float64Array([\n *   0.0, 0.0, 0.0,\n *   7500000.0, 0.0, 0.0,\n *   0.0, 7500000.0, 0.0\n * ]);\n *\n * var geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n *       componentsPerAttribute : 3,\n *       values : positions\n *     })\n *   },\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n *   primitiveType : Cesium.PrimitiveType.LINES,\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n * });\n */\n\nfunction Geometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.attributes\", options.attributes); //>>includeEnd('debug');\n\n  /**\n   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\n   * {@link GeometryAttribute} containing the attribute's data.\n   * <p>\n   * Attributes are always stored non-interleaved in a Geometry.\n   * </p>\n   * <p>\n   * There are reserved attribute names with well-known semantics.  The following attributes\n   * are created by a Geometry (depending on the provided {@link VertexFormat}.\n   * <ul>\n   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\n   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\n   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\n   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>\n   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\n   * </ul>\n   * </p>\n   * <p>\n   * The following attribute names are generally not created by a Geometry, but are added\n   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\n   * the geometry for rendering.\n   * <ul>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\n   * </ul>\n   * </p>\n   *\n   * @type GeometryAttributes\n   *\n   * @default undefined\n   *\n   *\n   * @example\n   * geometry.attributes.position = new Cesium.GeometryAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n   *   componentsPerAttribute : 3,\n   *   values : new Float32Array(0)\n   * });\n   *\n   * @see GeometryAttribute\n   * @see VertexFormat\n   */\n\n  this.attributes = options.attributes;\n  /**\n   * Optional index data that - along with {@link Geometry#primitiveType} -\n   * determines the primitives in the geometry.\n   *\n   * @type Array\n   *\n   * @default undefined\n   */\n\n  this.indices = options.indices;\n  /**\n   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\n   * but can varying based on the specific geometry.\n   *\n   * @type PrimitiveType\n   *\n   * @default undefined\n   */\n\n  this.primitiveType = defaultValue(options.primitiveType, PrimitiveType.TRIANGLES);\n  /**\n   * An optional bounding sphere that fully encloses the geometry.  This is\n   * commonly used for culling.\n   *\n   * @type BoundingSphere\n   *\n   * @default undefined\n   */\n\n  this.boundingSphere = options.boundingSphere;\n  /**\n   * @private\n   */\n\n  this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);\n  /**\n   * @private\n   */\n\n  this.boundingSphereCV = options.boundingSphereCV;\n  /**\n   * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute\n   * @private\n   */\n\n  this.offsetAttribute = options.offsetAttribute;\n}\n/**\n * Computes the number of vertices in a geometry.  The runtime is linear with\n * respect to the number of attributes in a vertex, not the number of vertices.\n *\n * @param {Geometry} geometry The geometry.\n * @returns {Number} The number of vertices in the geometry.\n *\n * @example\n * var numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\n */\n\n\nGeometry.computeNumberOfVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"geometry\", geometry); //>>includeEnd('debug');\n\n  var numberOfVertices = -1;\n\n  for (var property in geometry.attributes) {\n    if (geometry.attributes.hasOwnProperty(property) && defined(geometry.attributes[property]) && defined(geometry.attributes[property].values)) {\n      var attribute = geometry.attributes[property];\n      var num = attribute.values.length / attribute.componentsPerAttribute; //>>includeStart('debug', pragmas.debug);\n\n      if (numberOfVertices !== num && numberOfVertices !== -1) {\n        throw new DeveloperError(\"All attribute lists must have the same number of attributes.\");\n      } //>>includeEnd('debug');\n\n\n      numberOfVertices = num;\n    }\n  }\n\n  return numberOfVertices;\n};\n\nvar rectangleCenterScratch = new Cartographic();\nvar enuCenterScratch = new Cartesian3();\nvar fixedFrameToEnuScratch = new Matrix4();\nvar boundingRectanglePointsCartographicScratch = [new Cartographic(), new Cartographic(), new Cartographic()];\nvar boundingRectanglePointsEnuScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nvar pointEnuScratch = new Cartesian3();\nvar enuRotationScratch = new Quaternion();\nvar enuRotationMatrixScratch = new Matrix4();\nvar rotation2DScratch = new Matrix2();\n/**\n * For remapping texture coordinates when rendering GroundPrimitives with materials.\n * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.\n * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates\n * using different strategies.\n *\n * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.\n * We encapsulate rotation and scale by computing a \"transformed\" texture coordinate system and computing\n * a set of reference points from which \"cartographic\" texture coordinates can be remapped to the \"transformed\"\n * system using distances to lines in 2D.\n *\n * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,\n * but is generally reasonable for polygons and ellipses around the size of USA states.\n *\n * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space\n * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.\n *\n * @param {Cartesian3[]} positions Array of positions outlining the geometry\n * @param {Number} stRotation Texture coordinate rotation.\n * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.\n * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.\n * @returns {Number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the \"cartographic\" system.\n * @private\n */\n\nGeometry._textureCoordinateRotationPoints = function (positions, stRotation, ellipsoid, boundingRectangle) {\n  var i; // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.\n  // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.\n  // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordiante system computed in ShadowVolumeAppearanceFS,\n  // aka \"ENU texture space.\"\n\n  var rectangleCenter = Rectangle.center(boundingRectangle, rectangleCenterScratch);\n  var enuCenter = Cartographic.toCartesian(rectangleCenter, ellipsoid, enuCenterScratch);\n  var enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(enuCenter, ellipsoid, fixedFrameToEnuScratch);\n  var fixedFrameToEnu = Matrix4.inverse(enuToFixedFrame, fixedFrameToEnuScratch);\n  var boundingPointsEnu = boundingRectanglePointsEnuScratch;\n  var boundingPointsCarto = boundingRectanglePointsCartographicScratch;\n  boundingPointsCarto[0].longitude = boundingRectangle.west;\n  boundingPointsCarto[0].latitude = boundingRectangle.south;\n  boundingPointsCarto[1].longitude = boundingRectangle.west;\n  boundingPointsCarto[1].latitude = boundingRectangle.north;\n  boundingPointsCarto[2].longitude = boundingRectangle.east;\n  boundingPointsCarto[2].latitude = boundingRectangle.south;\n  var posEnu = pointEnuScratch;\n\n  for (i = 0; i < 3; i++) {\n    Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);\n    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);\n    boundingPointsEnu[i].x = posEnu.x;\n    boundingPointsEnu[i].y = posEnu.y;\n  } // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.\n  // Compute the bounding box of these rotated points in the 2D ENU plane.\n  // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.\n\n\n  var rotation = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -stRotation, enuRotationScratch);\n  var textureMatrix = Matrix3.fromQuaternion(rotation, enuRotationMatrixScratch);\n  var positionsLength = positions.length;\n  var enuMinX = Number.POSITIVE_INFINITY;\n  var enuMinY = Number.POSITIVE_INFINITY;\n  var enuMaxX = Number.NEGATIVE_INFINITY;\n  var enuMaxY = Number.NEGATIVE_INFINITY;\n\n  for (i = 0; i < positionsLength; i++) {\n    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, positions[i], posEnu);\n    posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);\n    enuMinX = Math.min(enuMinX, posEnu.x);\n    enuMinY = Math.min(enuMinY, posEnu.y);\n    enuMaxX = Math.max(enuMaxX, posEnu.x);\n    enuMaxY = Math.max(enuMaxY, posEnu.y);\n  }\n\n  var toDesiredInComputed = Matrix2.fromRotation(stRotation, rotation2DScratch);\n  var points2D = points2DScratch;\n  points2D[0].x = enuMinX;\n  points2D[0].y = enuMinY;\n  points2D[1].x = enuMinX;\n  points2D[1].y = enuMaxY;\n  points2D[2].x = enuMaxX;\n  points2D[2].y = enuMinY;\n  var boundingEnuMin = boundingPointsEnu[0];\n  var boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;\n  var boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;\n\n  for (i = 0; i < 3; i++) {\n    var point2D = points2D[i]; // rotate back\n\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D); // Convert point into east-north texture coordinate space\n\n    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;\n    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;\n  }\n\n  var minXYCorner = points2D[0];\n  var maxYCorner = points2D[1];\n  var maxXCorner = points2D[2];\n  var result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n  return result;\n};\n\nexport default Geometry;","map":{"version":3,"sources":["C:/Users/passa/Desktop/WaterDeployTrial/node_modules/cesium/Source/Core/Geometry.js"],"names":["Cartesian2","Cartesian3","Cartographic","Check","defaultValue","defined","DeveloperError","GeometryType","Matrix2","Matrix3","Matrix4","PrimitiveType","Quaternion","Rectangle","Transforms","Geometry","options","EMPTY_OBJECT","typeOf","object","attributes","indices","primitiveType","TRIANGLES","boundingSphere","geometryType","NONE","boundingSphereCV","offsetAttribute","computeNumberOfVertices","geometry","numberOfVertices","property","hasOwnProperty","values","attribute","num","length","componentsPerAttribute","rectangleCenterScratch","enuCenterScratch","fixedFrameToEnuScratch","boundingRectanglePointsCartographicScratch","boundingRectanglePointsEnuScratch","points2DScratch","pointEnuScratch","enuRotationScratch","enuRotationMatrixScratch","rotation2DScratch","_textureCoordinateRotationPoints","positions","stRotation","ellipsoid","boundingRectangle","i","rectangleCenter","center","enuCenter","toCartesian","enuToFixedFrame","eastNorthUpToFixedFrame","fixedFrameToEnu","inverse","boundingPointsEnu","boundingPointsCarto","longitude","west","latitude","south","north","east","posEnu","multiplyByPointAsVector","x","y","rotation","fromAxisAngle","UNIT_Z","textureMatrix","fromQuaternion","positionsLength","enuMinX","Number","POSITIVE_INFINITY","enuMinY","enuMaxX","NEGATIVE_INFINITY","enuMaxY","multiplyByVector","Math","min","max","toDesiredInComputed","fromRotation","points2D","boundingEnuMin","boundingPointsWidth","boundingPointsHeight","point2D","minXYCorner","maxYCorner","maxXCorner","result","Array","pack"],"mappings":"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","sourcesContent":["import Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeometryType from \"./GeometryType.js\";\nimport Matrix2 from \"./Matrix2.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Transforms from \"./Transforms.js\";\n\n/**\n * A geometry representation with attributes forming vertices and optional index data\n * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,\n * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can\n * be created from many heterogeneous - in many cases - geometries for performance.\n * <p>\n * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.\n * </p>\n *\n * @alias Geometry\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.\n * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.\n * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.\n * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.\n *\n * @see PolygonGeometry\n * @see RectangleGeometry\n * @see EllipseGeometry\n * @see CircleGeometry\n * @see WallGeometry\n * @see SimplePolylineGeometry\n * @see BoxGeometry\n * @see EllipsoidGeometry\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}\n *\n * @example\n * // Create geometry with a position attribute and indexed lines.\n * var positions = new Float64Array([\n *   0.0, 0.0, 0.0,\n *   7500000.0, 0.0, 0.0,\n *   0.0, 7500000.0, 0.0\n * ]);\n *\n * var geometry = new Cesium.Geometry({\n *   attributes : {\n *     position : new Cesium.GeometryAttribute({\n *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,\n *       componentsPerAttribute : 3,\n *       values : positions\n *     })\n *   },\n *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),\n *   primitiveType : Cesium.PrimitiveType.LINES,\n *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)\n * });\n */\nfunction Geometry(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.attributes\", options.attributes);\n  //>>includeEnd('debug');\n\n  /**\n   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a\n   * {@link GeometryAttribute} containing the attribute's data.\n   * <p>\n   * Attributes are always stored non-interleaved in a Geometry.\n   * </p>\n   * <p>\n   * There are reserved attribute names with well-known semantics.  The following attributes\n   * are created by a Geometry (depending on the provided {@link VertexFormat}.\n   * <ul>\n   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>\n   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>\n   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>\n   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>\n   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>\n   * </ul>\n   * </p>\n   * <p>\n   * The following attribute names are generally not created by a Geometry, but are added\n   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare\n   * the geometry for rendering.\n   * <ul>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>\n   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>\n   * </ul>\n   * </p>\n   *\n   * @type GeometryAttributes\n   *\n   * @default undefined\n   *\n   *\n   * @example\n   * geometry.attributes.position = new Cesium.GeometryAttribute({\n   *   componentDatatype : Cesium.ComponentDatatype.FLOAT,\n   *   componentsPerAttribute : 3,\n   *   values : new Float32Array(0)\n   * });\n   *\n   * @see GeometryAttribute\n   * @see VertexFormat\n   */\n  this.attributes = options.attributes;\n\n  /**\n   * Optional index data that - along with {@link Geometry#primitiveType} -\n   * determines the primitives in the geometry.\n   *\n   * @type Array\n   *\n   * @default undefined\n   */\n  this.indices = options.indices;\n\n  /**\n   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},\n   * but can varying based on the specific geometry.\n   *\n   * @type PrimitiveType\n   *\n   * @default undefined\n   */\n  this.primitiveType = defaultValue(\n    options.primitiveType,\n    PrimitiveType.TRIANGLES\n  );\n\n  /**\n   * An optional bounding sphere that fully encloses the geometry.  This is\n   * commonly used for culling.\n   *\n   * @type BoundingSphere\n   *\n   * @default undefined\n   */\n  this.boundingSphere = options.boundingSphere;\n\n  /**\n   * @private\n   */\n  this.geometryType = defaultValue(options.geometryType, GeometryType.NONE);\n\n  /**\n   * @private\n   */\n  this.boundingSphereCV = options.boundingSphereCV;\n\n  /**\n   * Used for computing the bounding sphere for geometry using the applyOffset vertex attribute\n   * @private\n   */\n  this.offsetAttribute = options.offsetAttribute;\n}\n\n/**\n * Computes the number of vertices in a geometry.  The runtime is linear with\n * respect to the number of attributes in a vertex, not the number of vertices.\n *\n * @param {Geometry} geometry The geometry.\n * @returns {Number} The number of vertices in the geometry.\n *\n * @example\n * var numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);\n */\nGeometry.computeNumberOfVertices = function (geometry) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"geometry\", geometry);\n  //>>includeEnd('debug');\n\n  var numberOfVertices = -1;\n  for (var property in geometry.attributes) {\n    if (\n      geometry.attributes.hasOwnProperty(property) &&\n      defined(geometry.attributes[property]) &&\n      defined(geometry.attributes[property].values)\n    ) {\n      var attribute = geometry.attributes[property];\n      var num = attribute.values.length / attribute.componentsPerAttribute;\n      //>>includeStart('debug', pragmas.debug);\n      if (numberOfVertices !== num && numberOfVertices !== -1) {\n        throw new DeveloperError(\n          \"All attribute lists must have the same number of attributes.\"\n        );\n      }\n      //>>includeEnd('debug');\n      numberOfVertices = num;\n    }\n  }\n\n  return numberOfVertices;\n};\n\nvar rectangleCenterScratch = new Cartographic();\nvar enuCenterScratch = new Cartesian3();\nvar fixedFrameToEnuScratch = new Matrix4();\nvar boundingRectanglePointsCartographicScratch = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nvar boundingRectanglePointsEnuScratch = [\n  new Cartesian2(),\n  new Cartesian2(),\n  new Cartesian2(),\n];\nvar points2DScratch = [new Cartesian2(), new Cartesian2(), new Cartesian2()];\nvar pointEnuScratch = new Cartesian3();\nvar enuRotationScratch = new Quaternion();\nvar enuRotationMatrixScratch = new Matrix4();\nvar rotation2DScratch = new Matrix2();\n\n/**\n * For remapping texture coordinates when rendering GroundPrimitives with materials.\n * GroundPrimitive texture coordinates are computed to align with the cartographic coordinate system on the globe.\n * However, EllipseGeometry, RectangleGeometry, and PolygonGeometry all bake rotations to per-vertex texture coordinates\n * using different strategies.\n *\n * This method is used by EllipseGeometry and PolygonGeometry to approximate the same visual effect.\n * We encapsulate rotation and scale by computing a \"transformed\" texture coordinate system and computing\n * a set of reference points from which \"cartographic\" texture coordinates can be remapped to the \"transformed\"\n * system using distances to lines in 2D.\n *\n * This approximation becomes less accurate as the covered area increases, especially for GroundPrimitives near the poles,\n * but is generally reasonable for polygons and ellipses around the size of USA states.\n *\n * RectangleGeometry has its own version of this method that computes remapping coordinates using cartographic space\n * as an intermediary instead of local ENU, which is more accurate for large-area rectangles.\n *\n * @param {Cartesian3[]} positions Array of positions outlining the geometry\n * @param {Number} stRotation Texture coordinate rotation.\n * @param {Ellipsoid} ellipsoid Ellipsoid for projecting and generating local vectors.\n * @param {Rectangle} boundingRectangle Bounding rectangle around the positions.\n * @returns {Number[]} An array of 6 numbers specifying [minimum point, u extent, v extent] as points in the \"cartographic\" system.\n * @private\n */\nGeometry._textureCoordinateRotationPoints = function (\n  positions,\n  stRotation,\n  ellipsoid,\n  boundingRectangle\n) {\n  var i;\n\n  // Create a local east-north-up coordinate system centered on the polygon's bounding rectangle.\n  // Project the southwest, northwest, and southeast corners of the bounding rectangle into the plane of ENU as 2D points.\n  // These are the equivalents of (0,0), (0,1), and (1,0) in the texture coordiante system computed in ShadowVolumeAppearanceFS,\n  // aka \"ENU texture space.\"\n  var rectangleCenter = Rectangle.center(\n    boundingRectangle,\n    rectangleCenterScratch\n  );\n  var enuCenter = Cartographic.toCartesian(\n    rectangleCenter,\n    ellipsoid,\n    enuCenterScratch\n  );\n  var enuToFixedFrame = Transforms.eastNorthUpToFixedFrame(\n    enuCenter,\n    ellipsoid,\n    fixedFrameToEnuScratch\n  );\n  var fixedFrameToEnu = Matrix4.inverse(\n    enuToFixedFrame,\n    fixedFrameToEnuScratch\n  );\n\n  var boundingPointsEnu = boundingRectanglePointsEnuScratch;\n  var boundingPointsCarto = boundingRectanglePointsCartographicScratch;\n\n  boundingPointsCarto[0].longitude = boundingRectangle.west;\n  boundingPointsCarto[0].latitude = boundingRectangle.south;\n\n  boundingPointsCarto[1].longitude = boundingRectangle.west;\n  boundingPointsCarto[1].latitude = boundingRectangle.north;\n\n  boundingPointsCarto[2].longitude = boundingRectangle.east;\n  boundingPointsCarto[2].latitude = boundingRectangle.south;\n\n  var posEnu = pointEnuScratch;\n\n  for (i = 0; i < 3; i++) {\n    Cartographic.toCartesian(boundingPointsCarto[i], ellipsoid, posEnu);\n    posEnu = Matrix4.multiplyByPointAsVector(fixedFrameToEnu, posEnu, posEnu);\n    boundingPointsEnu[i].x = posEnu.x;\n    boundingPointsEnu[i].y = posEnu.y;\n  }\n\n  // Rotate each point in the polygon around the up vector in the ENU by -stRotation and project into ENU as 2D.\n  // Compute the bounding box of these rotated points in the 2D ENU plane.\n  // Rotate the corners back by stRotation, then compute their equivalents in the ENU texture space using the corners computed earlier.\n  var rotation = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -stRotation,\n    enuRotationScratch\n  );\n  var textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    enuRotationMatrixScratch\n  );\n\n  var positionsLength = positions.length;\n  var enuMinX = Number.POSITIVE_INFINITY;\n  var enuMinY = Number.POSITIVE_INFINITY;\n  var enuMaxX = Number.NEGATIVE_INFINITY;\n  var enuMaxY = Number.NEGATIVE_INFINITY;\n  for (i = 0; i < positionsLength; i++) {\n    posEnu = Matrix4.multiplyByPointAsVector(\n      fixedFrameToEnu,\n      positions[i],\n      posEnu\n    );\n    posEnu = Matrix3.multiplyByVector(textureMatrix, posEnu, posEnu);\n\n    enuMinX = Math.min(enuMinX, posEnu.x);\n    enuMinY = Math.min(enuMinY, posEnu.y);\n    enuMaxX = Math.max(enuMaxX, posEnu.x);\n    enuMaxY = Math.max(enuMaxY, posEnu.y);\n  }\n\n  var toDesiredInComputed = Matrix2.fromRotation(stRotation, rotation2DScratch);\n\n  var points2D = points2DScratch;\n  points2D[0].x = enuMinX;\n  points2D[0].y = enuMinY;\n\n  points2D[1].x = enuMinX;\n  points2D[1].y = enuMaxY;\n\n  points2D[2].x = enuMaxX;\n  points2D[2].y = enuMinY;\n\n  var boundingEnuMin = boundingPointsEnu[0];\n  var boundingPointsWidth = boundingPointsEnu[2].x - boundingEnuMin.x;\n  var boundingPointsHeight = boundingPointsEnu[1].y - boundingEnuMin.y;\n\n  for (i = 0; i < 3; i++) {\n    var point2D = points2D[i];\n    // rotate back\n    Matrix2.multiplyByVector(toDesiredInComputed, point2D, point2D);\n\n    // Convert point into east-north texture coordinate space\n    point2D.x = (point2D.x - boundingEnuMin.x) / boundingPointsWidth;\n    point2D.y = (point2D.y - boundingEnuMin.y) / boundingPointsHeight;\n  }\n\n  var minXYCorner = points2D[0];\n  var maxYCorner = points2D[1];\n  var maxXCorner = points2D[2];\n  var result = new Array(6);\n  Cartesian2.pack(minXYCorner, result);\n  Cartesian2.pack(maxYCorner, result, 2);\n  Cartesian2.pack(maxXCorner, result, 4);\n\n  return result;\n};\nexport default Geometry;\n"]},"metadata":{},"sourceType":"module"}